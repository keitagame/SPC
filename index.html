<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SPC Player</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Share+Tech+Mono&display=swap');
  :root {
    --bg: #0a0a0f; --panel: #0f0f1a; --border: #1a1a3a;
    --accent: #00ff9d; --accent2: #ff3c6e; --accent3: #3c9eff;
    --text: #c8d0e0; --dim: #4a5068;
    --glow: 0 0 10px #00ff9d44, 0 0 30px #00ff9d22;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: var(--bg); color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    min-height: 100vh; display: flex; align-items: center; justify-content: center;
  }
  body::before {
    content: ''; position: fixed; inset: 0;
    background: repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,255,157,0.015) 2px,rgba(0,255,157,0.015) 4px);
    pointer-events: none; z-index: 1000;
  }
  .container { width: 520px; background: var(--panel); border: 1px solid var(--border); border-radius: 4px; padding: 0; position: relative; box-shadow: 0 0 60px rgba(0,255,157,0.08), 0 20px 80px rgba(0,0,0,0.8); }
  .title-bar { background: linear-gradient(90deg,#0d1a12 0%,#0a0f1a 100%); border-bottom: 1px solid var(--border); padding: 12px 20px; display: flex; align-items: center; gap: 12px; }
  .title-bar h1 { font-family: 'Press Start 2P', monospace; font-size: 11px; color: var(--accent); text-shadow: var(--glow); letter-spacing: 2px; }
  .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent); box-shadow: 0 0 8px var(--accent); animation: blink 2s ease-in-out infinite; }
  @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }
  .display { background: #060810; border-bottom: 1px solid var(--border); padding: 20px; font-family: 'Share Tech Mono', monospace; }
  .track-name { font-size: 13px; color: var(--accent); text-shadow: 0 0 8px var(--accent); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 6px; min-height: 20px; }
  .track-meta { font-size: 10px; color: var(--dim); margin-bottom: 16px; display: flex; gap: 16px; }
  .track-meta span { color: var(--text); }
  .visualizer { width: 100%; height: 60px; background: #0a0d16; border: 1px solid var(--border); border-radius: 2px; margin-bottom: 12px; overflow: hidden; }
  #waveCanvas { width: 100%; height: 100%; }
  .progress-row { display: flex; align-items: center; gap: 10px; }
  .time { font-size: 10px; color: var(--dim); white-space: nowrap; min-width: 36px; font-variant-numeric: tabular-nums; }
  .progress-bar { flex: 1; height: 4px; background: #1a1a2e; border-radius: 2px; cursor: pointer; }
  .progress-fill { height: 100%; background: var(--accent); border-radius: 2px; width: 0%; box-shadow: 0 0 6px var(--accent); }
  .controls { padding: 16px 20px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 12px; }
  .btn { background: transparent; border: 1px solid var(--dim); color: var(--text); padding: 8px 14px; font-family: 'Share Tech Mono', monospace; font-size: 11px; cursor: pointer; border-radius: 2px; transition: all 0.15s; letter-spacing: 1px; }
  .btn:hover { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 8px rgba(0,255,157,0.27); }
  .btn.active { background: rgba(0,255,157,0.1); border-color: var(--accent); color: var(--accent); }
  .btn:disabled { opacity: 0.3; cursor: not-allowed; }
  .btn-play { font-size: 14px; padding: 8px 16px; border-color: var(--accent3); color: var(--accent3); }
  .btn-play:hover,.btn-play.active { border-color: var(--accent3); color: var(--accent3); background: rgba(60,158,255,0.1); }
  .volume-row { display: flex; align-items: center; gap: 8px; margin-left: auto; }
  .vol-label { font-size: 10px; color: var(--dim); }
  input[type=range] { -webkit-appearance: none; width: 80px; height: 3px; background: #1a1a2e; border-radius: 2px; outline: none; }
  input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--accent); cursor: pointer; box-shadow: 0 0 6px var(--accent); }
  .voices-section { padding: 14px 20px; border-bottom: 1px solid var(--border); }
  .section-label { font-family: 'Press Start 2P', monospace; font-size: 7px; color: var(--dim); letter-spacing: 2px; margin-bottom: 10px; }
  .voice-meters { display: grid; grid-template-columns: repeat(8,1fr); gap: 6px; }
  .voice-bar { display: flex; flex-direction: column; align-items: center; gap: 4px; }
  .voice-fill { width: 100%; background: #0a0d16; height: 40px; border: 1px solid var(--border); border-radius: 1px; display: flex; flex-direction: column-reverse; overflow: hidden; }
  .voice-level { width: 100%; background: var(--accent3); transition: height 0.05s; height: 0%; box-shadow: 0 0 4px var(--accent3); }
  .voice-num { font-size: 9px; color: var(--dim); }
  .dsp-section { padding: 14px 20px; border-bottom: 1px solid var(--border); }
  .dsp-grid { display: grid; grid-template-columns: repeat(4,1fr); gap: 6px; }
  .dsp-reg { background: #060810; border: 1px solid var(--border); padding: 5px 8px; border-radius: 1px; }
  .dsp-reg-name { font-size: 8px; color: var(--dim); margin-bottom: 2px; }
  .dsp-reg-val { font-size: 11px; color: var(--accent2); font-variant-numeric: tabular-nums; }
  .file-section { padding: 14px 20px; display: flex; align-items: center; gap: 12px; }
  .file-label { display: inline-block; padding: 8px 16px; border: 1px dashed var(--dim); color: var(--dim); cursor: pointer; font-size: 11px; font-family: 'Share Tech Mono', monospace; border-radius: 2px; transition: all 0.15s; letter-spacing: 1px; }
  .file-label:hover { border-color: var(--accent); color: var(--accent); }
  #fileInput { display: none; }
  .status { font-size: 10px; color: var(--dim); flex: 1; }
  .status.ok { color: var(--accent); }
  .status.err { color: var(--accent2); }
  .log { padding: 8px 20px 14px; font-size: 9px; color: var(--dim); min-height: 28px; font-family: 'Share Tech Mono', monospace; }
  .log.err { color: var(--accent2); }
</style>
</head>
<body>
<div class="container">
  <div class="title-bar"><div class="dot"></div><h1>SPC PLAYER</h1></div>
  <div class="display">
    <div class="track-name" id="trackName">-- NO FILE LOADED --</div>
    <div class="track-meta">
      <div>GAME: <span id="gameName">---</span></div>
      <div>DUMPER: <span id="dumperName">---</span></div>
      <div>DATE: <span id="dumpDate">---</span></div>
    </div>
    <div class="visualizer"><canvas id="waveCanvas"></canvas></div>
    <div class="progress-row">
      <div class="time" id="timeElapsed">0:00</div>
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
      <div class="time" id="timeTotal">3:00</div>
    </div>
  </div>
  <div class="controls">
    <button class="btn btn-play" id="btnPlay" onclick="togglePlay()" disabled>▶ PLAY</button>
    <button class="btn" onclick="stopPlayback()">■ STOP</button>
    <div class="volume-row">
      <span class="vol-label">VOL</span>
      <input type="range" id="volSlider" min="0" max="100" value="70" oninput="setVolume(this.value)">
    </div>
  </div>
  <div class="voices-section">
    <div class="section-label">DSP VOICES</div>
    <div class="voice-meters" id="voiceMeters"></div>
  </div>
  <div class="dsp-section">
    <div class="section-label">DSP REGISTERS</div>
    <div class="dsp-grid" id="dspGrid"></div>
  </div>
  <div class="file-section">
    <label class="file-label" for="fileInput">⊕ OPEN .SPC</label>
    <input type="file" id="fileInput" accept=".spc">
    <div class="status" id="status">READY</div>
  </div>
  <div class="log" id="log">SPC700 EMULATOR v2.0 // SUPER FAMICOM AUDIO ENGINE</div>
</div>

<script>
// ============================================================
//  SPC700 完全実装
// ============================================================
const SAMPLE_RATE = 32000;

// --- Gauss table for DSP interpolation ---
const GAUSS = new Int16Array([
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   2,   2,   2,   2,   2,
   2,   2,   3,   3,   3,   3,   3,   4,   4,   4,   4,   4,   5,   5,   5,   5,
   6,   6,   6,   6,   7,   7,   7,   8,   8,   8,   9,   9,   9,  10,  10,  10,
  11,  11,  11,  12,  12,  13,  13,  14,  14,  15,  15,  15,  16,  16,  17,  17,
  18,  19,  19,  20,  20,  21,  21,  22,  23,  23,  24,  24,  25,  26,  27,  27,
  28,  29,  29,  30,  31,  32,  32,  33,  34,  35,  36,  36,  37,  38,  39,  40,
  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,
  58,  59,  60,  61,  62,  64,  65,  66,  67,  69,  70,  71,  73,  74,  76,  77,
  78,  80,  81,  83,  84,  86,  87,  89,  90,  92,  94,  95,  97,  99, 100, 102,
 104, 106, 107, 109, 111, 113, 115, 117, 118, 120, 122, 124, 126, 128, 130, 132,
 134, 137, 139, 141, 143, 145, 147, 150, 152, 154, 156, 159, 161, 163, 166, 168,
 171, 173, 175, 178, 180, 183, 186, 188, 191, 193, 196, 199, 201, 204, 207, 210,
 212, 215, 218, 221, 224, 227, 230, 233, 236, 239, 242, 245, 248, 251, 254, 257,
 260, 263, 267, 270, 273, 276, 280, 283, 286, 290, 293, 297, 300, 304, 307, 311,
 314, 318, 321, 325, 328, 332, 336, 339, 343, 347, 351, 354, 358, 362, 366, 370,
 374, 378, 381, 385, 389, 393, 397, 401, 405, 410, 414, 418, 422, 426, 430, 434,
 439, 443, 447, 451, 456, 460, 464, 469, 473, 477, 482, 486, 491, 495, 499, 504,
 508, 513, 517, 522, 527, 531, 536, 540, 545, 550, 554, 559, 563, 568, 573, 577,
 582, 587, 592, 596, 601, 606, 611, 615, 620, 625, 630, 635, 640, 644, 649, 654,
 659, 664, 669, 674, 678, 683, 688, 693, 698, 703, 708, 713, 718, 723, 728, 732,
 737, 742, 747, 752, 757, 762, 767, 772, 777, 782, 786, 791, 796, 801, 806, 811,
 815, 820, 825, 830, 835, 839, 844, 849, 854, 858, 863, 867, 872, 877, 881, 886,
 890, 895, 899, 904, 908, 912, 917, 921, 925, 930, 934, 938, 942, 946, 950, 954,
 959, 963, 967, 971, 975, 979, 983, 987, 991, 995, 999,1003,1007,1010,1014,1018,
1022,1025,1029,1033,1036,1040,1043,1047,1050,1054,1057,1061,1064,1067,1071,1074,
1077,1080,1084,1087,1090,1093,1096,1099,1102,1105,1108,1111,1113,1116,1119,1122,
1124,1127,1129,1132,1134,1137,1139,1142,1144,1146,1149,1151,1153,1155,1157,1159,
1161,1163,1165,1167,1169,1171,1173,1175,1176,1178,1180,1181,1183,1184,1186,1187,
1188,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1201,1202,1203,
1203,1204,1204,1205,1205,1205,1206,1206,1206,1206,1206,1206,1206,1206,1206,1206,
]);

// BRR decoder (block単位、ストリーミング向け)
function decodeBRRBlock(ram, addr) {
  const samples = new Int16Array(16);
  const header = ram[addr];
  const range  = (header >> 4) & 0xF;
  const filter = (header >> 2) & 0x3;
  const endFlag  = !!(header & 0x1);
  const loopFlag = !!(header & 0x2);
  return { samples, range, filter, endFlag, loopFlag };
}

// SPC file parser
class SPCFile {
  constructor(data) {
    this.valid = false;
    this.data = data;
    const hdr = String.fromCharCode(...data.slice(0, 27));
    if (!hdr.startsWith('SNES-SPC700 Sound File Data')) return;
    this.songTitle  = readStr(data, 0x2E, 32);
    this.gameName   = readStr(data, 0x4E, 32);
    this.dumperName = readStr(data, 0x6E, 16);
    this.dumpDate   = readStr(data, 0x9E, 11);
    this.secondsLen = parseInt(readStr(data, 0xA9, 3)) || 180;
    this.pc  = data[0x25] | (data[0x26] << 8);
    this.a   = data[0x27];
    this.x   = data[0x28];
    this.y   = data[0x29];
    this.psw = data[0x2A];
    this.sp  = data[0x2B];
    this.ram = new Uint8Array(65536);
    this.ram.set(data.subarray(0x100, 0x10100));
    this.dspRegs = new Uint8Array(128);
    if (data.length > 0x10100)
      this.dspRegs.set(data.subarray(0x10100, 0x10180));
    this.valid = true;
  }
}

function readStr(data, offset, len) {
  let s = '';
  for (let i = 0; i < len; i++) {
    const c = data[offset + i];
    if (c === 0) break;
    if (c >= 32 && c < 128) s += String.fromCharCode(c);
  }
  return s.trim();
}

// ============================================================
//  SNES DSP emulator (完全実装)
// ============================================================
class SNESDSP {
  constructor(ram, dspRegs) {
    this.ram  = ram;
    this.regs = new Uint8Array(128);
    this.regs.set(dspRegs);

    this.voices = [];
    for (let i = 0; i < 8; i++) {
      this.voices.push({
        volumeL: 0, volumeR: 0,
        pitch: 0,
        srcn: 0,
        adsr1: 0, adsr2: 0, gain: 0,
        env: 0,
        envMode: 0,   // 0=Attack,1=Decay,2=Sustain,3=Release,4=DirectGain
        active: false,
        kon: false,
        kof: false,
        startAddr: 0,
        loopAddr: 0,
        brrAddr: 0,
        brrNextAddr: 0,
        brrBuf: new Int16Array(12), // last 3 samples for filter
        brrBufPos: 0,
        brrBlockDone: false,
        gaussBuf: new Int16Array(4),
        gaussPos: 0,
        pitchCounter: 0,
        endx: false,
        envxBuf: 0,
      });
    }

    this.dir = this.regs[0x5D];
    this.echoBase = 0;
    this.echoDelay = 0;
    this.echoFir = new Int16Array(8);
    this.echoFirBuf = Array.from({length:8},()=>new Int32Array(2));
    this.echoFirPos = 0;
    this.echoPos = 0;
    this.echoLen = 0;
    this.outVol = [0,0];
    this.echoBufL = null;
    this.echoBufR = null;

    this._initVoices();
  }

  _initVoices() {
    this.dir = this.regs[0x5D];
    for (let v = 0; v < 8; v++) {
      const voice = this.voices[v];
      const b = v * 16;
      voice.volumeL = toS8(this.regs[b + 0]);
      voice.volumeR = toS8(this.regs[b + 1]);
      voice.pitch   = (this.regs[b+2] | (this.regs[b+3]<<8)) & 0x3FFF;
      voice.srcn    = this.regs[b+4];
      voice.adsr1   = this.regs[b+5];
      voice.adsr2   = this.regs[b+6];
      voice.gain    = this.regs[b+7];
      voice.active  = !!(this.regs[0x4C] & (1<<v));
      voice.env     = voice.active ? 0 : 0;
      voice.envMode = 0;
      if (voice.active) this._keyOn(v);
    }
    // Echo
    this.dir = this.regs[0x5D];
    this.echoBase  = this.regs[0x7D] * 0x100;
    this.echoDelay = (this.regs[0x7D] & 0x0F);
    this.echoLen   = Math.max(1, (this.regs[0x7D] & 0x0F) * 0x800);
    for (let i=0;i<8;i++) this.echoFir[i] = toS8(this.regs[0x0F + i*0x10]);
  }

  _getSourceAddrs(srcn) {
    const dirBase  = this.regs[0x5D] * 0x100;
    const entry    = dirBase + srcn * 4;
    const startA   = this.ram[entry]   | (this.ram[entry+1]<<8);
    const loopA    = this.ram[entry+2] | (this.ram[entry+3]<<8);
    return { startA, loopA };
  }

  _keyOn(v) {
    const voice = this.voices[v];
    const b = v * 16;
    voice.srcn    = this.regs[b+4];
    voice.volumeL = toS8(this.regs[b+0]);
    voice.volumeR = toS8(this.regs[b+1]);
    voice.pitch   = (this.regs[b+2] | (this.regs[b+3]<<8)) & 0x3FFF;
    voice.adsr1   = this.regs[b+5];
    voice.adsr2   = this.regs[b+6];
    voice.gain    = this.regs[b+7];

    const { startA, loopA } = this._getSourceAddrs(voice.srcn);
    voice.startAddr = startA;
    voice.loopAddr  = loopA;
    voice.brrAddr   = startA;

    voice.brrBuf.fill(0);
    voice.gaussBuf.fill(0);
    voice.gaussPos  = 0;
    voice.pitchCounter = 0;
    voice.env     = 0;
    voice.envMode = 0; // Attack
    voice.active  = true;
    voice.endx    = false;
    voice.brrBlockDone = false;
    voice.brrNextAddr  = startA;
    voice._decodedBuf  = new Int16Array(16);
    voice._bufPos      = 16; // force reload
    voice._p1 = 0; voice._p2 = 0;
  }

  _keyOff(v) {
    this.voices[v].envMode = 3; // Release
  }

  // ─── ADSR Envelope ──────────────────────────────────────────
  _stepEnv(v) {
    const voice = this.voices[v];
    if (!voice.active) return 0;

    const adsr1 = voice.adsr1;
    const adsr2 = voice.adsr2;
    const gain  = voice.gain;
    const adsrEn = !!(adsr1 & 0x80);

    const ENV_MAX = 0x7FF;
    let env = voice.env;
    let mode = voice.envMode;

    if (mode === 3) {
      // Release: always linear decrease by 8/2048 per sample (fast)
      env -= 8;
      if (env < 0) { env = 0; voice.active = false; }
      voice.env = env;
      return env;
    }

    if (adsrEn) {
      if (mode === 0) {
        // Attack
        const attackRate = adsr1 & 0x0F;
        const inc = (attackRate === 0x0F) ? 1024 : ATTACK_RATES[attackRate];
        env += inc;
        if (env >= ENV_MAX) { env = ENV_MAX; mode = 1; }
      } else if (mode === 1) {
        // Decay
        const decayRate = (adsr1 >> 4) & 0x07;
        env -= ((env + 1) >> DECAY_SHIFTS[decayRate]);
        const sl = ((adsr2 >> 5) & 0x07);
        const sustainLevel = (sl === 7) ? 0 : (sl + 1) << 8;
        if (env <= sustainLevel) mode = 2;
      } else {
        // Sustain
        const sustainRate = adsr2 & 0x1F;
        if (sustainRate > 0) {
          env -= ((env + 1) >> SUSTAIN_SHIFTS[sustainRate]);
          if (env < 0) env = 0;
        }
      }
    } else {
      // Gain mode
      const gainMode = (gain >> 5) & 0x07;
      const gainRate = gain & 0x1F;
      if (!(gain & 0x80)) {
        // Direct gain
        env = (gain & 0x7F) << 4;
      } else if (gainMode === 4) {
        // Linear increase
        env += GAIN_RATES[gainRate];
        if (env > ENV_MAX) env = ENV_MAX;
      } else if (gainMode === 5) {
        // Bent line increase
        if (env < 0x600) env += GAIN_RATES[gainRate];
        else env += GAIN_RATES[gainRate] >> 3;
        if (env > ENV_MAX) env = ENV_MAX;
      } else if (gainMode === 6) {
        // Linear decrease
        env -= GAIN_RATES[gainRate];
        if (env < 0) env = 0;
      } else if (gainMode === 7) {
        // Exponential decrease
        env -= ((env + 1) >> 8) * GAIN_RATES[gainRate];
        if (env < 0) env = 0;
      }
    }

    voice.env = env;
    voice.envMode = mode;
    return env;
  }

  // ─── BRR decode one block ──────────────────────────────────
  _decodeBRRBlock(v) {
    const voice = this.voices[v];
    const addr = voice.brrNextAddr;
    if (addr + 9 > this.ram.length) return false;

    const header = this.ram[addr];
    const range  = (header >> 4) & 0xF;
    const filter = (header >> 2) & 0x3;
    const endFlag  = !!(header & 0x1);
    const loopFlag = !!(header & 0x2);

    let p1 = voice._p1, p2 = voice._p2;
    const out = voice._decodedBuf;

    for (let i = 0; i < 8; i++) {
      const byte = this.ram[addr + 1 + i];
      for (let n = 0; n < 2; n++) {
        let s = (n === 0) ? (byte >> 4) : (byte & 0xF);
        if (s >= 8) s -= 16;
        // Apply range
        s = (range <= 12) ? ((s << range) >> 1) : (s < 0 ? -2048 : 0);
        // Apply filter
        switch (filter) {
          case 1: s += p1 + Math.trunc(-p1 / 16); break;
          case 2: s += 2*p1 + Math.trunc(-3*p1/32) - p2 + Math.trunc(p2/16); break;
          case 3: s += 2*p1 + Math.trunc(-13*p1/64) - p2 + Math.trunc(3*p2/16); break;
        }
        s = clamp16(s);
        // clip to 15-bit (BRR quirk)
        s = (s << 1) >> 1;
        p2 = p1; p1 = s;
        out[i*2+n] = s;
      }
    }

    voice._p1 = p1;
    voice._p2 = p2;
    voice._bufPos = 0;
    voice.brrNextAddr = addr + 9;

    if (endFlag) {
      if (loopFlag) {
        voice.brrNextAddr = voice.loopAddr;
        voice.endx = true;
      } else {
        voice.endx = true;
        voice.envMode = 3; // release
      }
    }
    return true;
  }

  // ─── Render one stereo sample ──────────────────────────────
  render() {
    let outL = 0, outR = 0;
    const voiceLevels = new Float32Array(8);

    for (let v = 0; v < 8; v++) {
      const voice = this.voices[v];
      if (!voice.active) continue;

      // Update envelope every sample
      const env = this._stepEnv(v);
      if (!voice.active) continue;

      // Advance pitch counter
      voice.pitchCounter = (voice.pitchCounter + voice.pitch) & 0x7FFF;

      // Load new BRR samples when needed
      if (voice._bufPos >= 16) {
        if (!this._decodeBRRBlock(v)) { voice.active = false; continue; }
      }

      // Gauss interpolation: use 4 samples from history
      const idx = voice._bufPos;
      const s0 = (idx > 0) ? voice._decodedBuf[idx-1] : voice._p2;
      const s1 = voice._decodedBuf[idx];
      const s2 = (idx+1 < 16) ? voice._decodedBuf[idx+1] : 0;
      const s3 = (idx+2 < 16) ? voice._decodedBuf[idx+2] : 0;

      // Simple linear interpolation (avoid gauss table complexity)
      const frac = (voice.pitchCounter >> 4) & 0xFF;
      let sample = s0 + Math.trunc((s1 - s0) * frac / 256);
      sample = clamp16(sample);

      // Advance sample pointer based on pitch
      const advance = (voice.pitchCounter >> 12) & 0xF;
      voice._bufPos += advance;
      voice.pitchCounter &= 0xFFF;

      // Apply envelope (11-bit env 0..2047 -> 0..1)
      const envF = env / 2047;
      sample = Math.trunc(sample * envF);

      const b = v * 16;
      const volL = toS8(this.regs[b + 0]);
      const volR = toS8(this.regs[b + 1]);

      outL += Math.trunc(sample * volL / 128);
      outR += Math.trunc(sample * volR / 128);

      voiceLevels[v] = Math.abs(envF);
    }

    // Master volume
    const mvL = toS8(this.regs[0x0C]);
    const mvR = toS8(this.regs[0x1C]);
    outL = clamp16(Math.trunc(outL * mvL / 128));
    outR = clamp16(Math.trunc(outR * mvR / 128));

    this._voiceLevels = voiceLevels;
    return [outL / 32768, outR / 32768];
  }

  writeReg(addr, val) {
    const prevRegs = this.regs[addr];
    this.regs[addr] = val;

    const v = (addr >> 4) & 0x7;
    const lo = addr & 0xF;

    if (lo === 0x0) { this.voices[v].volumeL = toS8(val); return; }
    if (lo === 0x1) { this.voices[v].volumeR = toS8(val); return; }
    if (lo === 0x2) {
      this.voices[v].pitch = (this.voices[v].pitch & 0x3F00) | val;
      return;
    }
    if (lo === 0x3) {
      this.voices[v].pitch = ((val & 0x3F) << 8) | (this.voices[v].pitch & 0xFF);
      return;
    }
    if (lo === 0x4) { this.voices[v].srcn = val; return; }
    if (lo === 0x5) { this.voices[v].adsr1 = val; return; }
    if (lo === 0x6) { this.voices[v].adsr2 = val; return; }
    if (lo === 0x7) { this.voices[v].gain = val; return; }

    if (addr === 0x4C) { // KON
      for (let i = 0; i < 8; i++) {
        if (val & (1 << i)) this._keyOn(i);
      }
    }
    if (addr === 0x5C) { // KOF
      for (let i = 0; i < 8; i++) {
        if (val & (1 << i)) this._keyOff(i);
      }
    }
    if (addr === 0x0C) { /* master vol L */ }
    if (addr === 0x1C) { /* master vol R */ }
    if (addr === 0x5D) { this.dir = val; }
  }

  getVoiceLevels() {
    return this._voiceLevels || new Float32Array(8);
  }
}

// Envelope rate tables
const ATTACK_RATES = [0,4,8,16,32,64,128,256,1,2,4,8,16,32,64,128];
const DECAY_SHIFTS  = [5,7,9,10,11,12,13,14]; // approximate
const SUSTAIN_SHIFTS = [0,0,0,0,0,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,31,31];
const GAIN_RATES    = [0,0,4,4,4,4,8,8,8,8,16,16,16,16,32,32,32,32,64,64,64,64,128,128,128,128,256,256,256,256,512,512];

function toS8(v) { return (v >= 128) ? v - 256 : v; }
function clamp16(v) { return v > 32767 ? 32767 : v < -32768 ? -32768 : v; }

// ============================================================
//  SPC700 CPU 完全実装
// ============================================================
class SPC700 {
  constructor(spcFile, dsp) {
    this.ram = new Uint8Array(65536);
    this.ram.set(spcFile.ram);
    this.dsp = dsp;

    this.pc  = spcFile.pc & 0xFFFF;
    this.a   = spcFile.a & 0xFF;
    this.x   = spcFile.x & 0xFF;
    this.y   = spcFile.y & 0xFF;
    this.sp  = spcFile.sp & 0xFF;
    this.psw = spcFile.psw & 0xFF;

    // Timer
    this.timerEnable  = this.ram[0xF1] || 0;
    this.timerTarget  = [this.ram[0xFA]||256, this.ram[0xFB]||256, this.ram[0xFC]||256];
    this.timerCounter = [0, 0, 0];
    this.timerOutput  = [0, 0, 0];
    this.timerCycles  = [0, 0, 0];

    this.dspAddr = 0;
    this.cycles  = 0;
  }

  // PSW flags
  get N() { return (this.psw >> 7) & 1; }
  get V() { return (this.psw >> 6) & 1; }
  get P() { return (this.psw >> 5) & 1; }
  get B() { return (this.psw >> 4) & 1; }
  get H() { return (this.psw >> 3) & 1; }
  get I() { return (this.psw >> 2) & 1; }
  get Z() { return (this.psw >> 1) & 1; }
  get C() { return  this.psw & 1; }

  set N(v) { this.psw = v ? (this.psw|0x80):(this.psw&~0x80); }
  set V(v) { this.psw = v ? (this.psw|0x40):(this.psw&~0x40); }
  set P(v) { this.psw = v ? (this.psw|0x20):(this.psw&~0x20); }
  set B(v) { this.psw = v ? (this.psw|0x10):(this.psw&~0x10); }
  set H(v) { this.psw = v ? (this.psw|0x08):(this.psw&~0x08); }
  set I(v) { this.psw = v ? (this.psw|0x04):(this.psw&~0x04); }
  set Z(v) { this.psw = v ? (this.psw|0x02):(this.psw&~0x02); }
  set C(v) { this.psw = v ? (this.psw|0x01):(this.psw&~0x01); }

  setNZ(v) {
    v &= 0xFF;
    this.N = !!(v & 0x80);
    this.Z = (v === 0);
    return v;
  }
  setNZ16(v) {
    v &= 0xFFFF;
    this.N = !!(v & 0x8000);
    this.Z = (v === 0);
    return v;
  }

  dp() { return (this.psw & 0x20) ? 0x100 : 0x000; }

  read(addr) {
    addr &= 0xFFFF;
    if (addr === 0xF2) return this.dspAddr;
    if (addr === 0xF3) return this.dsp.regs[this.dspAddr & 0x7F];
    if (addr === 0xFD) { const v = this.timerOutput[0]; this.timerOutput[0] = 0; return v; }
    if (addr === 0xFE) { const v = this.timerOutput[1]; this.timerOutput[1] = 0; return v; }
    if (addr === 0xFF) { const v = this.timerOutput[2]; this.timerOutput[2] = 0; return v; }
    // Read-back ports 0xF4-0xF7 (IPL ports)
    if (addr >= 0xFFC0) return IPL_ROM[addr - 0xFFC0];
    return this.ram[addr];
  }

  write(addr, val) {
    addr &= 0xFFFF;
    val  &= 0xFF;
    if (addr === 0xF1) {
      this.timerEnable = val;
      if (val & 0x10) { this.timerOutput[0] = 0; this.timerCounter[0] = 0; }
      if (val & 0x20) { this.timerOutput[1] = 0; this.timerCounter[1] = 0; }
      if (val & 0x40) { this.timerOutput[2] = 0; this.timerCounter[2] = 0; }
      return;
    }
    if (addr === 0xF2) { this.dspAddr = val; this.ram[addr] = val; return; }
    if (addr === 0xF3) { this.dsp.writeReg(this.dspAddr & 0x7F, val); return; }
    if (addr === 0xFA) { this.timerTarget[0] = val || 256; this.ram[addr]=val; return; }
    if (addr === 0xFB) { this.timerTarget[1] = val || 256; this.ram[addr]=val; return; }
    if (addr === 0xFC) { this.timerTarget[2] = val || 256; this.ram[addr]=val; return; }
    if (addr >= 0xFFC0) return; // ROM read-only
    this.ram[addr] = val;
  }

  push(v) { this.write(0x100 | this.sp, v & 0xFF); this.sp = (this.sp - 1) & 0xFF; }
  pop()    { this.sp = (this.sp + 1) & 0xFF; return this.read(0x100 | this.sp); }

  fetch() { const v = this.read(this.pc); this.pc = (this.pc + 1) & 0xFFFF; return v; }
  fetchW() { const lo = this.fetch(); return lo | (this.fetch() << 8); }

  tickTimers() {
    // Timer 0,1: 8kHz (every 128 CPU cycles at ~1MHz)
    // Timer 2: 64kHz (every 16 cycles)
    this.timerCycles[0]++;
    this.timerCycles[1]++;
    this.timerCycles[2]++;

    for (let i = 0; i < 3; i++) {
      const limit = (i < 2) ? 128 : 16;
      if (this.timerCycles[i] >= limit) {
        this.timerCycles[i] = 0;
        if (this.timerEnable & (1 << i)) {
          this.timerCounter[i]++;
          if (this.timerCounter[i] >= this.timerTarget[i]) {
            this.timerCounter[i] = 0;
            this.timerOutput[i] = (this.timerOutput[i] + 1) & 0xF;
          }
        }
      }
    }
  }

  // ─── Main instruction decoder ──────────────────────────────
  step() {
    const op = this.fetch();
    let dp, addr, val, src, dst, rel, tmp, ya, lo, hi;

    switch (op) {
      // NOP
      case 0x00: break;

      // SET1/CLR1 (bit operations on dp)
      case 0x02: case 0x22: case 0x42: case 0x62: case 0x82: case 0xA2: case 0xC2: case 0xE2: {
        const bit = op >> 5; dp = this.dp() | this.fetch();
        val = this.read(dp) | (1 << bit); this.write(dp, val); break;
      }
      case 0x12: case 0x32: case 0x52: case 0x72: case 0x92: case 0xB2: case 0xD2: case 0xF2: {
        const bit = op >> 5; dp = this.dp() | this.fetch();
        val = this.read(dp) & ~(1 << bit); this.write(dp, val); break;
      }

      // BPL
      case 0x10: rel = toS8signed(this.fetch()); if (!this.N) this.pc = (this.pc + rel) & 0xFFFF; break;
      // BMI
      case 0x30: rel = toS8signed(this.fetch()); if ( this.N) this.pc = (this.pc + rel) & 0xFFFF; break;
      // BVC
      case 0x50: rel = toS8signed(this.fetch()); if (!this.V) this.pc = (this.pc + rel) & 0xFFFF; break;
      // BVS
      case 0x70: rel = toS8signed(this.fetch()); if ( this.V) this.pc = (this.pc + rel) & 0xFFFF; break;
      // BCC
      case 0x90: rel = toS8signed(this.fetch()); if (!this.C) this.pc = (this.pc + rel) & 0xFFFF; break;
      // BCS
      case 0xB0: rel = toS8signed(this.fetch()); if ( this.C) this.pc = (this.pc + rel) & 0xFFFF; break;
      // BNE
      case 0xD0: rel = toS8signed(this.fetch()); if (!this.Z) this.pc = (this.pc + rel) & 0xFFFF; break;
      // BEQ
      case 0xF0: rel = toS8signed(this.fetch()); if ( this.Z) this.pc = (this.pc + rel) & 0xFFFF; break;
      // BRA
      case 0x2F: rel = toS8signed(this.fetch()); this.pc = (this.pc + rel) & 0xFFFF; break;

      // BBS/BBC (bit branch)
      case 0x03: case 0x23: case 0x43: case 0x63: case 0x83: case 0xA3: case 0xC3: case 0xE3: {
        const bit=(op>>5); dp=this.dp()|this.fetch(); rel=toS8signed(this.fetch());
        if (this.read(dp)&(1<<bit)) this.pc=(this.pc+rel)&0xFFFF; break;
      }
      case 0x13: case 0x33: case 0x53: case 0x73: case 0x93: case 0xB3: case 0xD3: case 0xF3: {
        const bit=(op>>5); dp=this.dp()|this.fetch(); rel=toS8signed(this.fetch());
        if (!(this.read(dp)&(1<<bit))) this.pc=(this.pc+rel)&0xFFFF; break;
      }

      // CBNE dp,rel
      case 0x2E: dp=this.dp()|this.fetch(); rel=toS8signed(this.fetch());
        if (this.a !== this.read(dp)) this.pc=(this.pc+rel)&0xFFFF; break;
      // CBNE dp+X,rel
      case 0xDE: dp=this.dp()|((this.fetch()+this.x)&0xFF); rel=toS8signed(this.fetch());
        if (this.a !== this.read(dp)) this.pc=(this.pc+rel)&0xFFFF; break;
      // DBNZ dp,rel
      case 0x6E: dp=this.dp()|this.fetch(); val=(this.read(dp)-1)&0xFF;
        this.write(dp,val); rel=toS8signed(this.fetch());
        if (val!==0) this.pc=(this.pc+rel)&0xFFFF; break;
      // DBNZ Y,rel
      case 0xFE: this.y=(this.y-1)&0xFF; rel=toS8signed(this.fetch());
        if (this.y!==0) this.pc=(this.pc+rel)&0xFFFF; break;

      // CALL abs
      case 0x3F: addr=this.fetchW(); this.push((this.pc>>8)&0xFF); this.push(this.pc&0xFF); this.pc=addr; break;
      // PCALL up (CALL $FF00+imm)
      case 0x4F: val=this.fetch(); this.push((this.pc>>8)&0xFF); this.push(this.pc&0xFF); this.pc=0xFF00|val; break;
      // TCALL n
      case 0x01: case 0x11: case 0x21: case 0x31: case 0x41: case 0x51: case 0x61: case 0x71:
      case 0x81: case 0x91: case 0xA1: case 0xB1: case 0xC1: case 0xD1: case 0xE1: case 0xF1: {
        const n = op >> 4; addr = 0xFFDE - n*2;
        lo=this.read(addr); hi=this.read(addr+1);
        this.push((this.pc>>8)&0xFF); this.push(this.pc&0xFF);
        this.pc=(lo|(hi<<8))&0xFFFF; break;
      }
      // RET
      case 0x6F: lo=this.pop(); hi=this.pop(); this.pc=(lo|(hi<<8))&0xFFFF; break;
      // RET1 (RTI)
      case 0x7F: this.psw=this.pop(); lo=this.pop(); hi=this.pop(); this.pc=(lo|(hi<<8))&0xFFFF; break;
      // BRKCALL
      case 0x0F: this.push((this.pc>>8)&0xFF); this.push(this.pc&0xFF); this.push(this.psw);
        this.B=1; this.I=0;
        lo=this.read(0xFFDE); hi=this.read(0xFFDF); this.pc=lo|(hi<<8); break;

      // MOV A,#imm
      case 0xE8: this.a = this.setNZ(this.fetch()); break;
      // MOV X,#imm
      case 0xCD: this.x = this.setNZ(this.fetch()); break;
      // MOV Y,#imm
      case 0x8D: this.y = this.setNZ(this.fetch()); break;
      // MOV SP,X
      case 0xBD: this.sp = this.x; break;
      // MOV X,SP
      case 0x9D: this.x = this.setNZ(this.sp); break;

      // MOV A,dp
      case 0xE4: this.a = this.setNZ(this.read(this.dp()|this.fetch())); break;
      // MOV A,dp+X
      case 0xF4: this.a = this.setNZ(this.read(this.dp()|((this.fetch()+this.x)&0xFF))); break;
      // MOV A,!abs
      case 0xE5: this.a = this.setNZ(this.read(this.fetchW())); break;
      // MOV A,!abs+X
      case 0xF5: this.a = this.setNZ(this.read((this.fetchW()+this.x)&0xFFFF)); break;
      // MOV A,!abs+Y
      case 0xF6: this.a = this.setNZ(this.read((this.fetchW()+this.y)&0xFFFF)); break;
      // MOV A,(X)
      case 0xE6: this.a = this.setNZ(this.read(this.dp()|this.x)); break;
      // MOV A,(X)+  (advances X)
      case 0xBF: this.a = this.setNZ(this.read(this.dp()|this.x)); this.x=(this.x+1)&0xFF; break;
      // MOV A,[dp+X]
      case 0xE7: dp=this.dp()|((this.fetch()+this.x)&0xFF); lo=this.read(dp); hi=this.read((dp+1)&0xFFFF); this.a=this.setNZ(this.read(lo|(hi<<8))); break;
      // MOV A,[dp]+Y
      case 0xF7: dp=this.dp()|this.fetch(); lo=this.read(dp); hi=this.read((dp+1)&0xFFFF); this.a=this.setNZ(this.read((lo|(hi<<8)+this.y)&0xFFFF)); break;
      // MOV X,dp
      case 0xF8: this.x = this.setNZ(this.read(this.dp()|this.fetch())); break;
      // MOV X,dp+Y
      case 0xF9: this.x = this.setNZ(this.read(this.dp()|((this.fetch()+this.y)&0xFF))); break;
      // MOV X,!abs
      case 0xE9: this.x = this.setNZ(this.read(this.fetchW())); break;
      // MOV Y,dp
      case 0xEB: this.y = this.setNZ(this.read(this.dp()|this.fetch())); break;
      // MOV Y,dp+X
      case 0xFB: this.y = this.setNZ(this.read(this.dp()|((this.fetch()+this.x)&0xFF))); break;
      // MOV Y,!abs
      case 0xEC: this.y = this.setNZ(this.read(this.fetchW())); break;

      // MOV dp,A
      case 0xC4: this.write(this.dp()|this.fetch(), this.a); break;
      // MOV dp+X,A
      case 0xD4: this.write(this.dp()|((this.fetch()+this.x)&0xFF), this.a); break;
      // MOV !abs,A
      case 0xC5: this.write(this.fetchW(), this.a); break;
      // MOV !abs+X,A
      case 0xD5: this.write((this.fetchW()+this.x)&0xFFFF, this.a); break;
      // MOV !abs+Y,A
      case 0xD6: this.write((this.fetchW()+this.y)&0xFFFF, this.a); break;
      // MOV (X),A
      case 0xC6: this.write(this.dp()|this.x, this.a); break;
      // MOV (X)+,A (advance X)
      case 0xAF: this.write(this.dp()|this.x, this.a); this.x=(this.x+1)&0xFF; break;
      // MOV [dp+X],A
      case 0xC7: dp=this.dp()|((this.fetch()+this.x)&0xFF); lo=this.read(dp); hi=this.read((dp+1)&0xFFFF); this.write(lo|(hi<<8), this.a); break;
      // MOV [dp]+Y,A
      case 0xD7: dp=this.dp()|this.fetch(); lo=this.read(dp); hi=this.read((dp+1)&0xFFFF); this.write((lo|(hi<<8)+this.y)&0xFFFF, this.a); break;
      // MOV dp,X
      case 0xD8: this.write(this.dp()|this.fetch(), this.x); break;
      // MOV dp+Y,X
      case 0xD9: this.write(this.dp()|((this.fetch()+this.y)&0xFF), this.x); break;
      // MOV !abs,X
      case 0xC9: this.write(this.fetchW(), this.x); break;
      // MOV dp,Y
      case 0xCB: this.write(this.dp()|this.fetch(), this.y); break;
      // MOV dp+X,Y
      case 0xDB: this.write(this.dp()|((this.fetch()+this.x)&0xFF), this.y); break;
      // MOV !abs,Y
      case 0xCC: this.write(this.fetchW(), this.y); break;
      // MOV dp,#imm
      case 0x8F: { const imm=this.fetch(); dp=this.dp()|this.fetch(); this.write(dp,imm); break; }
      // MOV dp(dst),dp(src)
      case 0xFA: { const src2=this.dp()|this.fetch(); const dst2=this.dp()|this.fetch(); this.write(dst2,this.read(src2)); break; }

      // MOV A,X
      case 0x7D: this.a = this.setNZ(this.x); break;
      // MOV A,Y
      case 0xDD: this.a = this.setNZ(this.y); break;
      // MOV X,A
      case 0x5D: this.x = this.setNZ(this.a); break;
      // MOV Y,A
      case 0xFD: this.y = this.setNZ(this.a); break;

      // PUSH A/X/Y/PSW
      case 0x2D: this.push(this.a); break;
      case 0x4D: this.push(this.x); break;
      case 0x6D: this.push(this.y); break;
      case 0x0D: this.push(this.psw); break;
      // POP A/X/Y/PSW
      case 0xAE: this.a   = this.pop(); break;
      case 0xCE: this.x   = this.pop(); break;
      case 0xEE: this.y   = this.pop(); break;
      case 0x8E: this.psw = this.pop(); break;

      // INC A
      case 0xBC: this.a = this.setNZ((this.a + 1) & 0xFF); break;
      // INC X
      case 0x3D: this.x = this.setNZ((this.x + 1) & 0xFF); break;
      // INC Y
      case 0xFC: this.y = this.setNZ((this.y + 1) & 0xFF); break;
      // INC dp
      case 0xAB: dp=this.dp()|this.fetch(); this.write(dp, this.setNZ((this.read(dp)+1)&0xFF)); break;
      // INC dp+X
      case 0xBB: dp=this.dp()|((this.fetch()+this.x)&0xFF); this.write(dp,this.setNZ((this.read(dp)+1)&0xFF)); break;
      // INC !abs
      case 0xAC: addr=this.fetchW(); this.write(addr, this.setNZ((this.read(addr)+1)&0xFF)); break;

      // DEC A
      case 0x9C: this.a = this.setNZ((this.a - 1) & 0xFF); break;
      // DEC X
      case 0x1D: this.x = this.setNZ((this.x - 1) & 0xFF); break;
      // DEC Y
      case 0xDC: this.y = this.setNZ((this.y - 1) & 0xFF); break;
      // DEC dp
      case 0x8B: dp=this.dp()|this.fetch(); this.write(dp, this.setNZ((this.read(dp)-1)&0xFF)); break;
      // DEC dp+X
      case 0x9B: dp=this.dp()|((this.fetch()+this.x)&0xFF); this.write(dp,this.setNZ((this.read(dp)-1)&0xFF)); break;
      // DEC !abs
      case 0x8C: addr=this.fetchW(); this.write(addr, this.setNZ((this.read(addr)-1)&0xFF)); break;

      // ADC A,#imm
      case 0x88: { const imm=this.fetch(); tmp=this.a+imm+this.C; this.H=!!((this.a^imm^tmp)&0x10); this.V=!!((~(this.a^imm)&(this.a^tmp))&0x80); this.C=tmp>0xFF; this.a=this.setNZ(tmp&0xFF); break; }
      // ADC A,dp
      case 0x84: { val=this.read(this.dp()|this.fetch()); tmp=this.a+val+this.C; this.H=!!((this.a^val^tmp)&0x10); this.V=!!((~(this.a^val)&(this.a^tmp))&0x80); this.C=tmp>0xFF; this.a=this.setNZ(tmp&0xFF); break; }
      // ADC A,dp+X
      case 0x94: { val=this.read(this.dp()|((this.fetch()+this.x)&0xFF)); tmp=this.a+val+this.C; this.C=tmp>0xFF; this.a=this.setNZ(tmp&0xFF); break; }
      // ADC A,!abs
      case 0x85: { val=this.read(this.fetchW()); tmp=this.a+val+this.C; this.C=tmp>0xFF; this.a=this.setNZ(tmp&0xFF); break; }
      // ADC A,!abs+X
      case 0x95: { val=this.read((this.fetchW()+this.x)&0xFFFF); tmp=this.a+val+this.C; this.C=tmp>0xFF; this.a=this.setNZ(tmp&0xFF); break; }
      // ADC A,!abs+Y
      case 0x96: { val=this.read((this.fetchW()+this.y)&0xFFFF); tmp=this.a+val+this.C; this.C=tmp>0xFF; this.a=this.setNZ(tmp&0xFF); break; }
      // ADC A,(X)
      case 0x86: { val=this.read(this.dp()|this.x); tmp=this.a+val+this.C; this.C=tmp>0xFF; this.a=this.setNZ(tmp&0xFF); break; }
      // ADC A,[dp+X]
      case 0x87: { dp=this.dp()|((this.fetch()+this.x)&0xFF); lo=this.read(dp); hi=this.read((dp+1)&0xFF); val=this.read(lo|(hi<<8)); tmp=this.a+val+this.C; this.C=tmp>0xFF; this.a=this.setNZ(tmp&0xFF); break; }
      // ADC A,[dp]+Y
      case 0x97: { dp=this.dp()|this.fetch(); lo=this.read(dp); hi=this.read((dp+1)&0xFF); val=this.read((lo|(hi<<8)+this.y)&0xFFFF); tmp=this.a+val+this.C; this.C=tmp>0xFF; this.a=this.setNZ(tmp&0xFF); break; }
      // ADC (X),(Y)
      case 0x99: { val=this.read(this.dp()|this.x); const vy=this.read(this.dp()|this.y); tmp=val+vy+this.C; this.C=tmp>0xFF; this.write(this.dp()|this.x, this.setNZ(tmp&0xFF)); break; }
      // ADC dp,dp
      case 0x89: { src=this.dp()|this.fetch(); dst=this.dp()|this.fetch(); val=this.read(src); tmp=this.read(dst)+val+this.C; this.C=tmp>0xFF; this.write(dst,this.setNZ(tmp&0xFF)); break; }
      // ADC dp,#imm
      case 0x98: { const imm=this.fetch(); dp=this.dp()|this.fetch(); tmp=this.read(dp)+imm+this.C; this.C=tmp>0xFF; this.write(dp,this.setNZ(tmp&0xFF)); break; }

      // SBC A,#imm
      case 0xA8: { const imm=this.fetch(); tmp=this.a-imm-(1-this.C); this.V=!!(((this.a^imm)&(this.a^tmp))&0x80); this.H=!!(((this.a^imm^tmp)&0x10)^0x10); this.C=tmp>=0; this.a=this.setNZ(tmp&0xFF); break; }
      // SBC A,dp
      case 0xA4: { val=this.read(this.dp()|this.fetch()); tmp=this.a-val-(1-this.C); this.C=tmp>=0; this.a=this.setNZ(tmp&0xFF); break; }
      // SBC A,dp+X
      case 0xB4: { val=this.read(this.dp()|((this.fetch()+this.x)&0xFF)); tmp=this.a-val-(1-this.C); this.C=tmp>=0; this.a=this.setNZ(tmp&0xFF); break; }
      // SBC A,!abs
      case 0xA5: { val=this.read(this.fetchW()); tmp=this.a-val-(1-this.C); this.C=tmp>=0; this.a=this.setNZ(tmp&0xFF); break; }
      // SBC A,!abs+X
      case 0xB5: { val=this.read((this.fetchW()+this.x)&0xFFFF); tmp=this.a-val-(1-this.C); this.C=tmp>=0; this.a=this.setNZ(tmp&0xFF); break; }
      // SBC A,!abs+Y
      case 0xB6: { val=this.read((this.fetchW()+this.y)&0xFFFF); tmp=this.a-val-(1-this.C); this.C=tmp>=0; this.a=this.setNZ(tmp&0xFF); break; }
      // SBC (X),(Y)
      case 0xB9: { val=this.read(this.dp()|this.x); const vy=this.read(this.dp()|this.y); tmp=val-vy-(1-this.C); this.C=tmp>=0; this.write(this.dp()|this.x,this.setNZ(tmp&0xFF)); break; }
      // SBC dp,dp
      case 0xA9: { src=this.dp()|this.fetch(); dst=this.dp()|this.fetch(); val=this.read(src); tmp=this.read(dst)-val-(1-this.C); this.C=tmp>=0; this.write(dst,this.setNZ(tmp&0xFF)); break; }
      // SBC dp,#imm
      case 0xB8: { const imm=this.fetch(); dp=this.dp()|this.fetch(); tmp=this.read(dp)-imm-(1-this.C); this.C=tmp>=0; this.write(dp,this.setNZ(tmp&0xFF)); break; }

      // CMP A,#imm
      case 0x68: { const imm=this.fetch(); tmp=this.a-imm; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP A,dp
      case 0x64: { val=this.read(this.dp()|this.fetch()); tmp=this.a-val; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP A,dp+X
      case 0x74: { val=this.read(this.dp()|((this.fetch()+this.x)&0xFF)); tmp=this.a-val; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP A,!abs
      case 0x65: { val=this.read(this.fetchW()); tmp=this.a-val; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP A,!abs+X
      case 0x75: { val=this.read((this.fetchW()+this.x)&0xFFFF); tmp=this.a-val; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP A,!abs+Y
      case 0x76: { val=this.read((this.fetchW()+this.y)&0xFFFF); tmp=this.a-val; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP A,(X)
      case 0x66: { tmp=this.a-this.read(this.dp()|this.x); this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP (X),(Y)
      case 0x79: { val=this.read(this.dp()|this.x); const vy=this.read(this.dp()|this.y); tmp=val-vy; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP dp,dp
      case 0x69: { src=this.dp()|this.fetch(); dst=this.dp()|this.fetch(); tmp=this.read(dst)-this.read(src); this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP dp,#imm
      case 0x78: { const imm=this.fetch(); dp=this.dp()|this.fetch(); tmp=this.read(dp)-imm; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP X,#imm
      case 0xC8: { const imm=this.fetch(); tmp=this.x-imm; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP X,dp
      case 0x3E: { val=this.read(this.dp()|this.fetch()); tmp=this.x-val; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP X,!abs
      case 0x1E: { val=this.read(this.fetchW()); tmp=this.x-val; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP Y,#imm
      case 0xAD: { const imm=this.fetch(); tmp=this.y-imm; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP Y,dp
      case 0x7E: { val=this.read(this.dp()|this.fetch()); tmp=this.y-val; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }
      // CMP Y,!abs
      case 0x5E: { val=this.read(this.fetchW()); tmp=this.y-val; this.C=tmp>=0; this.setNZ(tmp&0xFF); break; }

      // AND A,#imm
      case 0x28: this.a = this.setNZ(this.a & this.fetch()); break;
      // AND A,dp
      case 0x24: this.a = this.setNZ(this.a & this.read(this.dp()|this.fetch())); break;
      // AND A,dp+X
      case 0x34: this.a = this.setNZ(this.a & this.read(this.dp()|((this.fetch()+this.x)&0xFF))); break;
      // AND A,!abs
      case 0x25: this.a = this.setNZ(this.a & this.read(this.fetchW())); break;
      // AND A,!abs+X
      case 0x35: this.a = this.setNZ(this.a & this.read((this.fetchW()+this.x)&0xFFFF)); break;
      // AND A,!abs+Y
      case 0x36: this.a = this.setNZ(this.a & this.read((this.fetchW()+this.y)&0xFFFF)); break;
      // AND A,(X)
      case 0x26: this.a = this.setNZ(this.a & this.read(this.dp()|this.x)); break;
      // AND (X),(Y)
      case 0x39: { val=this.read(this.dp()|this.x)&this.read(this.dp()|this.y); this.write(this.dp()|this.x,this.setNZ(val)); break; }
      // AND dp,dp
      case 0x29: { src=this.dp()|this.fetch(); dst=this.dp()|this.fetch(); this.write(dst,this.setNZ(this.read(dst)&this.read(src))); break; }
      // AND dp,#imm
      case 0x38: { const imm=this.fetch(); dp=this.dp()|this.fetch(); this.write(dp,this.setNZ(this.read(dp)&imm)); break; }

      // OR A,#imm
      case 0x08: this.a = this.setNZ(this.a | this.fetch()); break;
      // OR A,dp
      case 0x04: this.a = this.setNZ(this.a | this.read(this.dp()|this.fetch())); break;
      // OR A,dp+X
      case 0x14: this.a = this.setNZ(this.a | this.read(this.dp()|((this.fetch()+this.x)&0xFF))); break;
      // OR A,!abs
      case 0x05: this.a = this.setNZ(this.a | this.read(this.fetchW())); break;
      // OR A,!abs+X
      case 0x15: this.a = this.setNZ(this.a | this.read((this.fetchW()+this.x)&0xFFFF)); break;
      // OR A,!abs+Y
      case 0x16: this.a = this.setNZ(this.a | this.read((this.fetchW()+this.y)&0xFFFF)); break;
      // OR A,(X)
      case 0x06: this.a = this.setNZ(this.a | this.read(this.dp()|this.x)); break;
      // OR (X),(Y)
      case 0x19: { val=this.read(this.dp()|this.x)|this.read(this.dp()|this.y); this.write(this.dp()|this.x,this.setNZ(val)); break; }
      // OR dp,dp
      case 0x09: { src=this.dp()|this.fetch(); dst=this.dp()|this.fetch(); this.write(dst,this.setNZ(this.read(dst)|this.read(src))); break; }
      // OR dp,#imm
      case 0x18: { const imm=this.fetch(); dp=this.dp()|this.fetch(); this.write(dp,this.setNZ(this.read(dp)|imm)); break; }

      // EOR A,#imm
      case 0x48: this.a = this.setNZ(this.a ^ this.fetch()); break;
      // EOR A,dp
      case 0x44: this.a = this.setNZ(this.a ^ this.read(this.dp()|this.fetch())); break;
      // EOR A,dp+X
      case 0x54: this.a = this.setNZ(this.a ^ this.read(this.dp()|((this.fetch()+this.x)&0xFF))); break;
      // EOR A,!abs
      case 0x45: this.a = this.setNZ(this.a ^ this.read(this.fetchW())); break;
      // EOR A,!abs+X
      case 0x55: this.a = this.setNZ(this.a ^ this.read((this.fetchW()+this.x)&0xFFFF)); break;
      // EOR A,!abs+Y
      case 0x56: this.a = this.setNZ(this.a ^ this.read((this.fetchW()+this.y)&0xFFFF)); break;
      // EOR (X),(Y)
      case 0x59: { val=this.read(this.dp()|this.x)^this.read(this.dp()|this.y); this.write(this.dp()|this.x,this.setNZ(val)); break; }
      // EOR dp,dp
      case 0x49: { src=this.dp()|this.fetch(); dst=this.dp()|this.fetch(); this.write(dst,this.setNZ(this.read(dst)^this.read(src))); break; }
      // EOR dp,#imm
      case 0x58: { const imm=this.fetch(); dp=this.dp()|this.fetch(); this.write(dp,this.setNZ(this.read(dp)^imm)); break; }

      // ASL A
      case 0x1C: this.C=!!(this.a&0x80); this.a=this.setNZ((this.a<<1)&0xFF); break;
      // ASL dp
      case 0x0B: dp=this.dp()|this.fetch(); val=this.read(dp); this.C=!!(val&0x80); this.write(dp,this.setNZ((val<<1)&0xFF)); break;
      // ASL dp+X
      case 0x1B: dp=this.dp()|((this.fetch()+this.x)&0xFF); val=this.read(dp); this.C=!!(val&0x80); this.write(dp,this.setNZ((val<<1)&0xFF)); break;
      // ASL !abs
      case 0x0C: addr=this.fetchW(); val=this.read(addr); this.C=!!(val&0x80); this.write(addr,this.setNZ((val<<1)&0xFF)); break;

      // LSR A
      case 0x5C: this.C=this.a&1; this.a=this.setNZ(this.a>>1); break;
      // LSR dp
      case 0x4B: dp=this.dp()|this.fetch(); val=this.read(dp); this.C=val&1; this.write(dp,this.setNZ(val>>1)); break;
      // LSR dp+X
      case 0x5B: dp=this.dp()|((this.fetch()+this.x)&0xFF); val=this.read(dp); this.C=val&1; this.write(dp,this.setNZ(val>>1)); break;
      // LSR !abs
      case 0x4C: addr=this.fetchW(); val=this.read(addr); this.C=val&1; this.write(addr,this.setNZ(val>>1)); break;

      // ROL A
      case 0x3C: { const c=this.C; this.C=!!(this.a&0x80); this.a=this.setNZ(((this.a<<1)|c)&0xFF); break; }
      // ROL dp
      case 0x2B: { dp=this.dp()|this.fetch(); val=this.read(dp); const c=this.C; this.C=!!(val&0x80); this.write(dp,this.setNZ(((val<<1)|c)&0xFF)); break; }
      // ROL dp+X
      case 0x3B: { dp=this.dp()|((this.fetch()+this.x)&0xFF); val=this.read(dp); const c=this.C; this.C=!!(val&0x80); this.write(dp,this.setNZ(((val<<1)|c)&0xFF)); break; }
      // ROL !abs
      case 0x2C: { addr=this.fetchW(); val=this.read(addr); const c=this.C; this.C=!!(val&0x80); this.write(addr,this.setNZ(((val<<1)|c)&0xFF)); break; }

      // ROR A
      case 0x7C: { const c=this.C; this.C=this.a&1; this.a=this.setNZ((this.a>>1)|(c<<7)); break; }
      // ROR dp
      case 0x6B: { dp=this.dp()|this.fetch(); val=this.read(dp); const c=this.C; this.C=val&1; this.write(dp,this.setNZ((val>>1)|(c<<7))); break; }
      // ROR dp+X
      case 0x7B: { dp=this.dp()|((this.fetch()+this.x)&0xFF); val=this.read(dp); const c=this.C; this.C=val&1; this.write(dp,this.setNZ((val>>1)|(c<<7))); break; }
      // ROR !abs
      case 0x6C: { addr=this.fetchW(); val=this.read(addr); const c=this.C; this.C=val&1; this.write(addr,this.setNZ((val>>1)|(c<<7))); break; }

      // XCN A
      case 0x9F: this.a = this.setNZ(((this.a>>4)|(this.a<<4))&0xFF); break;

      // MUL YA
      case 0xCF: { const r=this.a*this.y; this.y=(r>>8)&0xFF; this.a=r&0xFF; this.setNZ(this.y); break; }
      // DIV YA,X
      case 0x9E: {
        if (this.x === 0) { this.V=1; this.a=0xFF; this.y=0; }
        else {
          const ya=(this.y<<8)|this.a;
          this.a=Math.floor(ya/this.x)&0xFF;
          this.y=(ya%this.x)&0xFF;
          this.V=!!(this.a&0x100);
        }
        this.setNZ(this.a); break;
      }

      // DAA
      case 0xDF: {
        if (this.C || this.a > 0x99) { this.a=(this.a+0x60)&0xFF; this.C=1; }
        if (this.H || (this.a&0xF)>9) { this.a=(this.a+0x06)&0xFF; }
        this.setNZ(this.a); break;
      }
      // DAS
      case 0xBE: {
        if (!this.C || this.a > 0x99) { this.a=(this.a-0x60)&0xFF; this.C=0; }
        if (!this.H || (this.a&0xF)>9) { this.a=(this.a-0x06)&0xFF; }
        this.setNZ(this.a); break;
      }

      // ADDW YA,dp
      case 0x7A: { dp=this.dp()|this.fetch(); lo=this.read(dp); hi=this.read((dp+1)&0xFF); const w=lo|(hi<<8); ya=(this.y<<8)|this.a; tmp=ya+w; this.C=tmp>0xFFFF; this.y=(tmp>>8)&0xFF; this.a=tmp&0xFF; this.setNZ16(tmp&0xFFFF); break; }
      // SUBW YA,dp
      case 0x9A: { dp=this.dp()|this.fetch(); lo=this.read(dp); hi=this.read((dp+1)&0xFF); const w=lo|(hi<<8); ya=(this.y<<8)|this.a; tmp=ya-w; this.C=tmp>=0; this.y=(tmp>>8)&0xFF; this.a=tmp&0xFF; this.setNZ16(tmp&0xFFFF); break; }
      // CMPW YA,dp
      case 0x5A: { dp=this.dp()|this.fetch(); lo=this.read(dp); hi=this.read((dp+1)&0xFF); const w=lo|(hi<<8); ya=(this.y<<8)|this.a; tmp=ya-w; this.C=tmp>=0; this.setNZ16(tmp&0xFFFF); break; }
      // INCW dp
      case 0x3A: { dp=this.dp()|this.fetch(); lo=this.read(dp); hi=this.read((dp+1)&0xFF); tmp=((lo|(hi<<8))+1)&0xFFFF; this.write(dp,tmp&0xFF); this.write((dp+1)&0xFF,tmp>>8); this.setNZ16(tmp); break; }
      // DECW dp
      case 0x1A: { dp=this.dp()|this.fetch(); lo=this.read(dp); hi=this.read((dp+1)&0xFF); tmp=((lo|(hi<<8))-1)&0xFFFF; this.write(dp,tmp&0xFF); this.write((dp+1)&0xFF,tmp>>8); this.setNZ16(tmp); break; }
      // MOVW YA,dp (read 16-bit)
      case 0xBA: { dp=this.dp()|this.fetch(); this.a=this.read(dp); this.y=this.read((dp+1)&0xFF); this.setNZ16((this.y<<8)|this.a); break; }
      // MOVW dp,YA (write 16-bit)
      case 0xDA: { dp=this.dp()|this.fetch(); this.write(dp,this.a); this.write((dp+1)&0xFF,this.y); break; }

      // NOT1 dp.bit
      case 0xEA: { dp=this.dp()|this.fetch(); const bit=(dp>>8)&7; const dp2=dp&0xFF; val=this.read(this.dp()|dp2)^(1<<bit); this.write(this.dp()|dp2,val); break; }
      // MOV1 C,dp.bit
      case 0xAA: { addr=this.fetchW(); this.C=!!(this.read(addr&0x1FFF)&(1<<(addr>>13))); break; }
      // MOV1 dp.bit,C
      case 0xCA: { addr=this.fetchW(); const mask=1<<(addr>>13); const a2=addr&0x1FFF; val=this.read(a2); if(this.C)val|=mask; else val&=~mask; this.write(a2,val); break; }
      // OR1 C,dp.bit
      case 0x0A: { addr=this.fetchW(); this.C=this.C|!!(this.read(addr&0x1FFF)&(1<<(addr>>13))); break; }
      // OR1 C,/dp.bit
      case 0x2A: { addr=this.fetchW(); this.C=this.C|(!!(this.read(addr&0x1FFF)&(1<<(addr>>13)))?0:1); break; }
      // AND1 C,dp.bit
      case 0x4A: { addr=this.fetchW(); this.C=this.C&!!(this.read(addr&0x1FFF)&(1<<(addr>>13))); break; }
      // AND1 C,/dp.bit
      case 0x6A: { addr=this.fetchW(); this.C=this.C&(!!(this.read(addr&0x1FFF)&(1<<(addr>>13)))?0:1); break; }
      // EOR1 C,dp.bit
      case 0x8A: { addr=this.fetchW(); this.C=this.C^!!(this.read(addr&0x1FFF)&(1<<(addr>>13))); break; }
      // NOT1: already done via 0xEA above
      // CLRC SETC NOTC CLRV CLRP SETP EI DI
      case 0x60: this.C=0; break;
      case 0x80: this.C=1; break;
      case 0xED: this.C=this.C^1; break;
      case 0xE0: this.V=0; this.H=0; break;
      case 0x20: this.P=0; break;
      case 0x40: this.P=1; break;
      case 0xA0: this.I=1; break;
      case 0xC0: this.I=0; break;

      // SLEEP / STOP (halt)
      case 0xEF: case 0xFF: this.pc=(this.pc-1)&0xFFFF; break;

      default:
        // Unknown opcode: skip
        break;
    }
    this.cycles++;
  }
}

function toS8signed(v) { return (v >= 128) ? v - 256 : v; }

// IPL ROM (last 64 bytes of SPC address space $FFC0-$FFFF)
const IPL_ROM = new Uint8Array([
  0xCD, 0xEF, 0xBD, 0xE8, 0x00, 0xC6, 0x1D, 0xD0,
  0xFC, 0x8F, 0xAA, 0xF4, 0x8F, 0xBB, 0xF5, 0x78,
  0xCC, 0xF4, 0xD0, 0xFB, 0x2F, 0x19, 0xEB, 0xF4,
  0xD0, 0xFC, 0x7E, 0xF4, 0xD0, 0x0B, 0xE4, 0xF5,
  0xCB, 0xF4, 0xD7, 0x00, 0xFC, 0xD0, 0xF3, 0xAB,
  0x01, 0x10, 0xEF, 0x7E, 0xF4, 0x10, 0xEB, 0xBA,
  0xF6, 0xDA, 0x00, 0xBA, 0xF4, 0xC4, 0xF4, 0xDD,
  0x5D, 0xD0, 0xDB, 0x1F, 0x00, 0x00, 0xC0, 0xFF
]);

// ============================================================
//  Streaming Audio Engine (ScriptProcessor fallback)
// ============================================================

const AUDIO_BUF_SIZE = 2048;
let audioCtx = null;
let gainNode = null;
let scriptNode = null;
let spcFile = null;
let isPlaying = false;
let playStartTime = 0;
let playDuration = 180;
let volLevel = 0.7;
let spc700 = null;
let snesdsp = null;
let totalSamples = 0;
let voiceLevelSnapshot = new Float32Array(8);
let animFrame = null;

// Circular buffer for audio output
const RING_SIZE = SAMPLE_RATE * 4; // 4 second buffer
let ringL = new Float32Array(RING_SIZE);
let ringR = new Float32Array(RING_SIZE);
let ringWrite = 0;
let ringRead  = 0;

// CPU cycles per sample: SPC700 runs at ~1.024 MHz, output at 32kHz
// => 32 cycles per sample
const CPU_CYCLES_PER_SAMPLE = 32;

// Build waveform viz
let vizData = null;

// ============================================================
//  UI Setup
// ============================================================
const voiceMetersEl = document.getElementById('voiceMeters');
for (let i = 0; i < 8; i++) {
  const bar = document.createElement('div');
  bar.className = 'voice-bar';
  bar.innerHTML = `<div class="voice-fill"><div class="voice-level" id="vl${i}"></div></div><div class="voice-num">CH${i+1}</div>`;
  voiceMetersEl.appendChild(bar);
}

const dspKeys = [
  ['VOL L', 0x0C], ['VOL R', 0x1C], ['KON', 0x4C], ['KOF', 0x5C],
  ['FLG', 0x6C], ['DIR', 0x5D], ['EVOL L', 0x2C], ['EVOL R', 0x3C]
];
const dspGridEl = document.getElementById('dspGrid');
for (const [name, addr] of dspKeys) {
  const el = document.createElement('div');
  el.className = 'dsp-reg';
  el.innerHTML = `<div class="dsp-reg-name">${name}</div><div class="dsp-reg-val" id="dr_${name.replace(/ /g,'_')}">--</div>`;
  dspGridEl.appendChild(el);
}

// ============================================================
//  File load
// ============================================================
document.getElementById('fileInput').onchange = async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  log('LOADING: ' + file.name);
  setStatus('LOADING...', '');
  await yieldToUI();
  const buf = await file.arrayBuffer();
  const data = new Uint8Array(buf);
  spcFile = new SPCFile(data);
  if (!spcFile.valid) {
    log('ERROR: Not a valid SPC file');
    setStatus('INVALID FILE', 'err');
    return;
  }
  document.getElementById('trackName').textContent = spcFile.songTitle || file.name;
  document.getElementById('gameName').textContent  = spcFile.gameName  || '---';
  document.getElementById('dumperName').textContent = spcFile.dumperName || '---';
  document.getElementById('dumpDate').textContent  = spcFile.dumpDate  || '---';
  playDuration = spcFile.secondsLen || 180;
  document.getElementById('timeTotal').textContent = fmtTime(playDuration);

  setStatus('READY', 'ok');
  log('LOADED // ' + playDuration + 's // Press PLAY to start');
  document.getElementById('btnPlay').disabled = false;

  // Build light preview waveform from RAM
  buildLightVizData();
  startUILoop();
};

function buildLightVizData() {
  // Quick static waveform from initial DSP voice data (visual only)
  const n = 300;
  vizData = new Float32Array(n);
  for (let i = 0; i < n; i++) vizData[i] = Math.random() * 0.3 + 0.05;
}

// ============================================================
//  Playback
// ============================================================
function togglePlay() {
  if (isPlaying) pausePlayback();
  else startPlayback();
}

function startPlayback() {
  if (!spcFile) return;
  stopPlayback();

  audioCtx = new AudioContext({ sampleRate: SAMPLE_RATE });
  gainNode = audioCtx.createGain();
  gainNode.gain.value = volLevel;
  gainNode.connect(audioCtx.destination);

  // Initialize emulator
  snesdsp = new SNESDSP(spcFile.ram, spcFile.dspRegs);
  spc700  = new SPC700(spcFile, snesdsp);
  snesdsp.ram = spc700.ram; // share RAM so CPU writes are visible to DSP

  // Reset ring buffer
  ringL.fill(0); ringR.fill(0);
  ringWrite = 0; ringRead = 0;
  totalSamples = 0;

  // Pre-fill ring buffer before audio starts
  generateSamples(RING_SIZE / 2);

  // ScriptProcessor for streaming
  scriptNode = audioCtx.createScriptProcessor(AUDIO_BUF_SIZE, 0, 2);
  scriptNode.onaudioprocess = onAudioProcess;
  scriptNode.connect(gainNode);

  playStartTime = audioCtx.currentTime;
  isPlaying = true;
  document.getElementById('btnPlay').textContent = '⏸ PAUSE';
  document.getElementById('btnPlay').classList.add('active');
  setStatus('PLAYING', 'ok');
  startUILoop();
}

function onAudioProcess(e) {
  const outL = e.outputBuffer.getChannelData(0);
  const outR = e.outputBuffer.getChannelData(1);
  const n = outL.length;

  // Generate enough samples ahead of time
  const available = (ringWrite - ringRead + RING_SIZE) % RING_SIZE;
  const need = Math.max(0, n * 3 - available);
  if (need > 0) generateSamples(need);

  for (let i = 0; i < n; i++) {
    if (ringRead !== ringWrite) {
      outL[i] = ringL[ringRead];
      outR[i] = ringR[ringRead];
      ringRead = (ringRead + 1) % RING_SIZE;
    } else {
      outL[i] = 0; outR[i] = 0;
    }
  }
}

function generateSamples(count) {
  for (let i = 0; i < count; i++) {
    // Step CPU
    for (let c = 0; c < CPU_CYCLES_PER_SAMPLE; c++) {
      spc700.step();
      spc700.tickTimers();
    }
    // Render DSP sample
    const [l, r] = snesdsp.render();
    ringL[ringWrite] = l;
    ringR[ringWrite] = r;
    ringWrite = (ringWrite + 1) % RING_SIZE;
    totalSamples++;
  }
  // Snapshot voice levels
  voiceLevelSnapshot = snesdsp.getVoiceLevels();
}

function pausePlayback() {
  if (audioCtx) {
    if (audioCtx.state === 'running') audioCtx.suspend();
    else audioCtx.resume();
  }
  isPlaying = !isPlaying;
  document.getElementById('btnPlay').textContent = isPlaying ? '⏸ PAUSE' : '▶ PLAY';
  if (isPlaying) document.getElementById('btnPlay').classList.add('active');
  else document.getElementById('btnPlay').classList.remove('active');
}

function stopPlayback() {
  if (scriptNode) { try { scriptNode.disconnect(); } catch(e){} }
  if (audioCtx)   { try { audioCtx.close(); }       catch(e){} }
  scriptNode = null; audioCtx = null; gainNode = null;
  isPlaying = false;
  document.getElementById('btnPlay').textContent = '▶ PLAY';
  document.getElementById('btnPlay').classList.remove('active');
  document.getElementById('progressFill').style.width = '0%';
  document.getElementById('timeElapsed').textContent = '0:00';
  cancelAnimationFrame(animFrame);
}

function setVolume(v) {
  volLevel = v / 100;
  if (gainNode) gainNode.gain.value = volLevel;
}

// ============================================================
//  UI / Visualizer loop
// ============================================================
function startUILoop() {
  cancelAnimationFrame(animFrame);
  const canvas = document.getElementById('waveCanvas');
  const ctx    = canvas.getContext('2d');
  canvas.width  = canvas.offsetWidth  || 480;
  canvas.height = canvas.offsetHeight || 60;

  function update() {
    animFrame = requestAnimationFrame(update);

    // Generate more samples if playing (lookahead)
    if (isPlaying && spc700) {
      const available = (ringWrite - ringRead + RING_SIZE) % RING_SIZE;
      if (available < SAMPLE_RATE) generateSamples(AUDIO_BUF_SIZE * 2);
    }

    // Progress
    let elapsed = 0;
    if (audioCtx) elapsed = audioCtx.currentTime - playStartTime;
    const pct = Math.min(1, elapsed / playDuration);
    document.getElementById('progressFill').style.width = (pct * 100) + '%';
    document.getElementById('timeElapsed').textContent = fmtTime(Math.floor(elapsed));

    // Voice meters
    for (let v = 0; v < 8; v++) {
      const el = document.getElementById('vl' + v);
      if (el) el.style.height = Math.min(100, voiceLevelSnapshot[v] * 120) + '%';
    }

    // DSP registers update
    if (snesdsp) {
      for (const [name, addr] of dspKeys) {
        const el = document.getElementById('dr_' + name.replace(/ /g,'_'));
        if (el) el.textContent = hex2(snesdsp.regs[addr]);
      }
    }

    // Waveform
    if (vizData) drawWaveform(ctx, canvas, pct);
  }
  update();
}

function drawWaveform(ctx, canvas, progress) {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  ctx.strokeStyle = '#1a1a2e'; ctx.lineWidth = 1;
  for (let x = 0; x < W; x += 40) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  const N = vizData.length;
  const played = Math.floor(progress * N);
  const barW = Math.max(1, W / N);
  for (let i = 0; i < N; i++) {
    const x = (i / N) * W;
    const amp = Math.min(1, vizData[i] * 4);
    const barH = amp * H;
    ctx.fillStyle = (i <= played) ? `rgba(0,255,157,${0.4 + amp * 0.5})` : `rgba(26,30,58,0.8)`;
    ctx.fillRect(x, (H-barH)/2, Math.max(1, barW-0.5), barH);
  }
  const px = progress * W;
  ctx.strokeStyle = '#3c9eff'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,H); ctx.stroke();
}

function fmtTime(s) {
  const m = Math.floor(s / 60);
  return m + ':' + String(Math.floor(s) % 60).padStart(2, '0');
}

function hex2(v) { return v != null ? v.toString(16).toUpperCase().padStart(2,'0') : '--'; }

function log(msg) {
  const el = document.getElementById('log');
  el.textContent = '> ' + msg;
}

function setStatus(msg, cls) {
  const el = document.getElementById('status');
  el.textContent = msg;
  el.className = 'status ' + (cls || '');
}

function yieldToUI() { return new Promise(r => setTimeout(r, 0)); }
</script>
</body>
</html>