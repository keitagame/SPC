<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SPC Player</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Share+Tech+Mono&display=swap');

  :root {
    --bg: #0a0a0f;
    --panel: #0f0f1a;
    --border: #1a1a3a;
    --accent: #00ff9d;
    --accent2: #ff3c6e;
    --accent3: #3c9eff;
    --text: #c8d0e0;
    --dim: #4a5068;
    --glow: 0 0 10px #00ff9d44, 0 0 30px #00ff9d22;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,255,157,0.015) 2px,
      rgba(0,255,157,0.015) 4px
    );
    pointer-events: none;
    z-index: 1000;
  }

  .container {
    width: 520px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0;
    position: relative;
    box-shadow: 0 0 60px rgba(0,255,157,0.08), 0 20px 80px rgba(0,0,0,0.8);
  }

  .title-bar {
    background: linear-gradient(90deg, #0d1a12 0%, #0a0f1a 100%);
    border-bottom: 1px solid var(--border);
    padding: 12px 20px;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .title-bar h1 {
    font-family: 'Press Start 2P', monospace;
    font-size: 11px;
    color: var(--accent);
    text-shadow: var(--glow);
    letter-spacing: 2px;
  }

  .dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
    animation: blink 2s ease-in-out infinite;
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  .display {
    background: #060810;
    border-bottom: 1px solid var(--border);
    padding: 20px;
    font-family: 'Share Tech Mono', monospace;
  }

  .track-name {
    font-size: 13px;
    color: var(--accent);
    text-shadow: 0 0 8px var(--accent);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 6px;
    min-height: 20px;
  }

  .track-meta {
    font-size: 10px;
    color: var(--dim);
    margin-bottom: 16px;
    display: flex;
    gap: 16px;
  }

  .track-meta span { color: var(--text); }

  /* Waveform visualizer */
  .visualizer {
    width: 100%;
    height: 60px;
    background: #0a0d16;
    border: 1px solid var(--border);
    border-radius: 2px;
    margin-bottom: 12px;
    overflow: hidden;
    position: relative;
  }

  #waveCanvas {
    width: 100%; height: 100%;
  }

  /* Progress */
  .progress-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 0;
  }

  .time {
    font-size: 10px;
    color: var(--dim);
    white-space: nowrap;
    min-width: 36px;
    font-variant-numeric: tabular-nums;
  }

  .progress-bar {
    flex: 1;
    height: 4px;
    background: #1a1a2e;
    border-radius: 2px;
    position: relative;
    cursor: pointer;
  }

  .progress-fill {
    height: 100%;
    background: var(--accent);
    border-radius: 2px;
    width: 0%;
    transition: width 0.5s linear;
    box-shadow: 0 0 6px var(--accent);
  }

  /* Controls */
  .controls {
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .btn {
    background: transparent;
    border: 1px solid var(--dim);
    color: var(--text);
    padding: 8px 14px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    cursor: pointer;
    border-radius: 2px;
    transition: all 0.15s;
    letter-spacing: 1px;
  }

  .btn:hover {
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 0 8px var(--accent)44;
  }

  .btn.active {
    background: rgba(0,255,157,0.1);
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 0 10px var(--accent)44;
  }

  .btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }

  .btn-play {
    font-size: 14px;
    padding: 8px 16px;
    border-color: var(--accent3);
    color: var(--accent3);
  }

  .btn-play:hover, .btn-play.active {
    border-color: var(--accent3);
    color: var(--accent3);
    background: rgba(60,158,255,0.1);
    box-shadow: 0 0 10px rgba(60,158,255,0.3);
  }

  .volume-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-left: auto;
  }

  .vol-label {
    font-size: 10px;
    color: var(--dim);
  }

  input[type=range] {
    -webkit-appearance: none;
    width: 80px;
    height: 3px;
    background: #1a1a2e;
    border-radius: 2px;
    outline: none;
  }

  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 6px var(--accent);
  }

  /* Voice meters */
  .voices-section {
    padding: 14px 20px;
    border-bottom: 1px solid var(--border);
  }

  .section-label {
    font-family: 'Press Start 2P', monospace;
    font-size: 7px;
    color: var(--dim);
    letter-spacing: 2px;
    margin-bottom: 10px;
  }

  .voice-meters {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 6px;
  }

  .voice-bar {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }

  .voice-fill {
    width: 100%;
    background: #0a0d16;
    height: 40px;
    border: 1px solid var(--border);
    border-radius: 1px;
    display: flex;
    flex-direction: column-reverse;
    overflow: hidden;
    position: relative;
  }

  .voice-level {
    width: 100%;
    background: var(--accent3);
    transition: height 0.05s;
    height: 0%;
    box-shadow: 0 0 4px var(--accent3);
  }

  .voice-num {
    font-size: 9px;
    color: var(--dim);
  }

  /* DSP Registers display */
  .dsp-section {
    padding: 14px 20px;
    border-bottom: 1px solid var(--border);
  }

  .dsp-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
  }

  .dsp-reg {
    background: #060810;
    border: 1px solid var(--border);
    padding: 5px 8px;
    border-radius: 1px;
  }

  .dsp-reg-name {
    font-size: 8px;
    color: var(--dim);
    margin-bottom: 2px;
  }

  .dsp-reg-val {
    font-size: 11px;
    color: var(--accent2);
    font-variant-numeric: tabular-nums;
  }

  /* File area */
  .file-section {
    padding: 14px 20px;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .file-label {
    display: inline-block;
    padding: 8px 16px;
    border: 1px dashed var(--dim);
    color: var(--dim);
    cursor: pointer;
    font-size: 11px;
    font-family: 'Share Tech Mono', monospace;
    border-radius: 2px;
    transition: all 0.15s;
    letter-spacing: 1px;
  }

  .file-label:hover {
    border-color: var(--accent);
    color: var(--accent);
  }

  #fileInput { display: none; }

  .status {
    font-size: 10px;
    color: var(--dim);
    flex: 1;
  }

  .status.ok { color: var(--accent); }
  .status.err { color: var(--accent2); }

  /* Error log */
  .log {
    padding: 8px 20px 14px;
    font-size: 9px;
    color: var(--dim);
    min-height: 28px;
    font-family: 'Share Tech Mono', monospace;
  }

  .log.err { color: var(--accent2); }
</style>
</head>
<body>

<div class="container">
  <div class="title-bar">
    <div class="dot"></div>
    <h1>SPC PLAYER</h1>
  </div>
<div id="cpuTrace" style="
  font-family: monospace;
  white-space: pre;
  background:#000;
  color:#0f0;
  height:200px;
  overflow:auto;
  padding:8px;
"></div>
  <div class="display">
    <div class="track-name" id="trackName">-- NO FILE LOADED --</div>
    <div class="track-meta">
      <div>GAME: <span id="gameName">---</span></div>
      <div>DUMPER: <span id="dumperName">---</span></div>
      <div>DATE: <span id="dumpDate">---</span></div>
    </div>
    <div class="visualizer">
      <canvas id="waveCanvas"></canvas>
    </div>
    <div class="progress-row">
      <div class="time" id="timeElapsed">0:00</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="time" id="timeTotal">3:00</div>
    </div>
  </div>

  <div class="controls">
    <button class="btn btn-play" id="btnPlay" onclick="togglePlay()" disabled>▶ PLAY</button>
    <button class="btn" onclick="stopPlayback()">■ STOP</button>
    <div class="volume-row">
      <span class="vol-label">VOL</span>
      <input type="range" id="volSlider" min="0" max="100" value="70" oninput="setVolume(this.value)">
    </div>
  </div>

  <div class="voices-section">
    <div class="section-label">DSP VOICES</div>
    <div class="voice-meters" id="voiceMeters"></div>
  </div>

  <div class="dsp-section">
    <div class="section-label">DSP REGISTERS</div>
    <div class="dsp-grid" id="dspGrid"></div>
  </div>

  <div class="file-section">
    <label class="file-label" for="fileInput">⊕ OPEN .SPC</label>
    <input type="file" id="fileInput" accept=".spc">
    <div class="status" id="status">READY</div>
  </div>

  <div class="log" id="log">SPC700 EMULATOR v1.0 // SUPER FAMICOM AUDIO ENGINE</div>
</div>

<script>
// ============================================================
//  SPC700 + SNES DSP Emulator
//  Implements: BRR decode, DSP envelope (ADSR/GAIN), voices
// ============================================================

const SAMPLE_RATE = 32000;
const PLAY_DURATION = 180; // 3 min default

// --- BRR Decoder ---
function decodeBRR(ram, startAddr, loopAddr, numSamples) {
  const out = new Float32Array(numSamples + 16);
  let addr = startAddr;
  let p1 = 0, p2 = 0;
  let outIdx = 0;

  for (let block = 0; outIdx < numSamples; block++) {
    if (addr + 8 > ram.length) break;
    const header = ram[addr];
    const range = (header >> 4) & 0xF;
    const filter = (header >> 2) & 0x3;
    const endFlag = header & 0x1;
    const loopFlag = header & 0x2;

    for (let i = 0; i < 8; i++) {
      const byte = ram[addr + 1 + i];
      const nibbles = [(byte >> 4) & 0xF, byte & 0xF];

      for (let n = 0; n < 2; n++) {
        let s = nibbles[n];
        if (s >= 8) s -= 16;

        // apply range
        if (range <= 12) s = (s << range) >> 1;
        else s = (s < 0 ? -2048 : 0);

        // apply filter
        switch (filter) {
          case 1: s += p1 + (-p1 >> 4); break;
          case 2: s += 2*p1 + ((-3*p1) >> 5) - p2 + (p2 >> 4); break;
          case 3: s += 2*p1 + ((-13*p1) >> 6) - p2 + ((3*p2) >> 4); break;
        }

        s = Math.max(-32768, Math.min(32767, s));
        p2 = p1;
        p1 = s;

        if (outIdx < numSamples) {
          out[outIdx++] = s / 32768.0;
        }
      }
    }

    addr += 9;

    if (endFlag) {
      if (loopFlag && loopAddr !== addr) {
        addr = loopAddr;
        // allow looping a few times
      } else {
        break;
      }
    }
  }

  return out;
}

// --- SPC file parser ---
class SPCFile {
  constructor(data) {
    this.valid = false;
    this.data = data;

    // Check header
    const hdr = String.fromCharCode(...data.slice(0, 27));
    if (!hdr.startsWith('SNES-SPC700 Sound File Data')) {
      return;
    }

    // Tags
    this.songTitle  = readStr(data, 0x2E, 32);
    this.gameName   = readStr(data, 0x4E, 32);
    this.dumperName = readStr(data, 0x6E, 16);
    this.comments   = readStr(data, 0x7E, 32);
    this.dumpDate   = readStr(data, 0x9E, 11);
    this.secondsLen = parseInt(readStr(data, 0xA9, 3)) || 180;
    this.fadeLen    = parseInt(readStr(data, 0xAC, 5)) || 10000;

    // SPC state
    this.pc   = data[0x25] | (data[0x26] << 8);
    this.a    = data[0x27];
    this.x    = data[0x28];
    this.y    = data[0x29];
    this.psw  = data[0x2A];
    this.sp   = data[0x2B];

    // RAM (64KB from offset 0x100)
    this.ram = new Uint8Array(65536);
    for (let i = 0; i < 65536; i++)
      this.ram[i] = data[0x100 + i];

    // DSP registers (from offset 0x10100)
    this.dspRegs = new Uint8Array(128);
    if (data.length > 0x10100) {
      for (let i = 0; i < 128; i++)
        this.dspRegs[i] = data[0x10100 + i];
    }

    this.valid = true;
  }
}

function readStr(data, offset, len) {
  let s = '';
  for (let i = 0; i < len; i++) {
    const c = data[offset + i];
    if (c === 0) break;
    if (c >= 32 && c < 128) s += String.fromCharCode(c);
  }
  return s.trim();
}
class SPCMusicSequencer {
  constructor(spcFile, dsp) {
    this.ram = spcFile.ram;
    this.dsp = dsp;

    this.time = 0;
    this.events = [];

    this.extractEvents();
  }

  extractEvents() {
    // 簡易：RAMからDSP書き込みパターンを探索
    for (let i = 0; i < 65536 - 3; i++) {
      if (this.ram[i] === 0x8F) { // MOV dp,#imm (多くのドライバ)
        const val = this.ram[i+1];
        const addr = this.ram[i+2];

        // DSP I/Oポート
        if (addr === 0xF2) {
          const dspAddr = val;
          const next = this.ram[i+3];

          if (next === 0x8F) {
            const dspVal = this.ram[i+4];
            const port = this.ram[i+5];

            if (port === 0xF3) {
              this.events.push({
                time: this.events.length * 2000,
                addr: dspAddr,
                val: dspVal
              });
            }
          }
        }
      }
    }

    // なければ初期DSPをイベント化
    if (this.events.length === 0) {
      for (let i = 0; i < 128; i++) {
        this.events.push({
          time: i * 1000,
          addr: i,
          val: this.dsp.regs[i]
        });
      }
    }
  }

  tick(sample) {
    while (this.events.length &&
           sample >= this.events[0].time) {
      const ev = this.events.shift();
      this.dsp.writeReg(ev.addr, ev.val);
    }
  }
}
class SPC700 {
  constructor(spcFile, dsp) {
    this.ram = spcFile.ram;
    this.dsp = dsp;
this.traceBuffer = "";
    this.traceLines = 0;
  
    this.pc = spcFile.pc;
    this.a = spcFile.a;
    this.x = spcFile.x;
    this.y = spcFile.y;
    this.sp = spcFile.sp;
    this.psw = spcFile.psw;

    this.cycles = 0;

    this.timer = [0,0,0];
    this.timerTarget = [0,0,0];
    this.timerCounter = [0,0,0];

    this.dspAddr = 0;
  }
push(v){
  this.ram[0x100 + this.sp] = v;
  this.sp = (this.sp - 1) & 255;
}
push(v){
  this.write(0x100 | this.sp, v);
  this.sp = (this.sp - 1) & 0xFF;
}

pop(){
  this.sp = (this.sp + 1) & 0xFF;
  return this.read(0x100 | this.sp);
}
pop(){
  this.sp = (this.sp + 1) & 255;
  return this.ram[0x100 + this.sp];
}
setZN(v){
  if (v===0) this.psw |= 0x02;
  else this.psw &= ~0x02;

  if (v&0x80) this.psw |= 0x80;
  else this.psw &= ~0x80;
}

zeroFlag(){
  return (this.psw & 0x02) !== 0;
}
  step() {
    const pcBefore = this.pc;
    const op = this.ram[this.pc++];

    switch(op) {

      // MOV A, #imm
      case 0xE8:
        this.a = this.ram[this.pc++];
        break;

      // MOV addr, A
      case 0xC4: {
        const addr = this.ram[this.pc++];
        this.write(addr, this.a);
        break;
      }

      // MOV A, addr
      case 0xE4: {
        const addr = this.ram[this.pc++];
        this.a = this.read(addr);
        break;
      }
case 0x3F: { // CALL abs
  const lo = this.ram[this.pc++];
  const hi = this.ram[this.pc++];
  const addr = lo | (hi<<8);
  this.push((this.pc>>8)&255);
  this.push(this.pc&255);
  this.pc = addr;
  break;
}

case 0x6F: { // RET
  const lo = this.pop();
  const hi = this.pop();
  this.pc = lo | (hi<<8);
  break;
}
case 0xD0: { // BNE
  const rel = this.ram[this.pc++];
  if (!this.zeroFlag())
    this.pc += (rel<128?rel:rel-256);
  break;
}
// ADC A,#imm
case 0x88: {
  const imm = this.ram[this.pc++];
  const c = this.c ? 1 : 0;
  const r = this.a + imm + c;
  this.c = r > 0xFF;
  this.a = r & 0xFF;
  this.setZN(this.a);
  break;
}

// ADC A,dp
case 0x84: {
  const dp = this.ram[this.pc++];
  const v = this.read(dp);
  const c = this.c ? 1 : 0;
  const r = this.a + v + c;
  this.c = r > 0xFF;
  this.a = r & 0xFF;
  this.setZN(this.a);
  break;
}
// SBC A,#imm
case 0xA8: {
  const imm = this.ram[this.pc++];
  const c = this.c ? 0 : 1;
  const r = this.a - imm - c;
  this.c = r >= 0;
  this.a = r & 0xFF;
  this.setZN(this.a);
  break;
}
case 0xF0: { // BEQ
  const rel = this.ram[this.pc++];
  if (this.zeroFlag())
    this.pc += (rel<128?rel:rel-256);
  break;
}
// CMP A,#imm
case 0x68: {
  const imm = this.ram[this.pc++];
  const r = this.a - imm;
  this.c = r >= 0;
  this.setZN(r & 0xFF);
  break;
}
// INC dp
case 0xAB: {
  const dp = this.ram[this.pc++];
  const v = (this.read(dp) + 1) & 0xFF;
  this.write(dp, v);
  this.setZN(v);
  break;
}

// DEC dp
case 0x8B: {
  const dp = this.ram[this.pc++];
  const v = (this.read(dp) - 1) & 0xFF;
  this.write(dp, v);
  this.setZN(v);
  break;
}
// MOV A,(dp+X)
case 0xF4: {
  const dp = this.ram[this.pc++];
  const addr = (dp + this.x) & 0xFF;
  this.a = this.read(addr);
  this.setZN(this.a);
  break;
}

// MOV (dp+X),A
case 0xD4: {
  const dp = this.ram[this.pc++];
  const addr = (dp + this.x) & 0xFF;
  this.write(addr, this.a);
  break;
}
// ADDW YA,dp
case 0x7A: {
  const dp = this.ram[this.pc++];
  const lo = this.read(dp);
  const hi = this.read((dp+1)&0xFF);
  const val = lo | (hi<<8);

  const ya = (this.y<<8)|this.a;
  const r = ya + val;

  this.y = (r >> 8) & 0xFF;
  this.a = r & 0xFF;
  this.setZN(this.a);
  break;
}
// SET1 dp.bit
case 0x02: {
  const dp = this.ram[this.pc++];
  const bit = (this.ram[this.pc++] >> 5) & 7;
  const v = this.read(dp) | (1<<bit);
  this.write(dp, v);
  break;
}

// CLR1 dp.bit
case 0x12: {
  const dp = this.ram[this.pc++];
  const bit = (this.ram[this.pc++] >> 5) & 7;
  const v = this.read(dp) & ~(1<<bit);
  this.write(dp, v);
  break;
}
// BCS
case 0xB0: {
  const rel = (this.ram[this.pc++]<<24)>>24;
  if(this.c) this.pc = (this.pc + rel) & 0xFFFF;
  break;
}

// BCC
case 0x90: {
  const rel = (this.ram[this.pc++]<<24)>>24;
  if(!this.c) this.pc = (this.pc + rel) & 0xFFFF;
  break;
}

// BMI
case 0x30: {
  const rel = (this.ram[this.pc++]<<24)>>24;
  if(this.n) this.pc = (this.pc + rel) & 0xFFFF;
  break;
}

// BPL
case 0x10: {
  const rel = (this.ram[this.pc++]<<24)>>24;
  if(!this.n) this.pc = (this.pc + rel) & 0xFFFF;
  break;
}
case 0x88: { // ADC A,#imm
  const v = this.ram[this.pc++];
  this.a = (this.a + v)&255;
  this.setZN(this.a);
  break;
}
      // INC addr
      case 0xAB: {
        const addr = this.ram[this.pc++];
        this.write(addr, (this.read(addr)+1)&255);
        break;
      }

      // DEC addr
      case 0x8B: {
        const addr = this.ram[this.pc++];
        this.write(addr, (this.read(addr)-1)&255);
        break;
      }
// MOV A,(X)
case 0xF6: {
  this.a = this.read(this.x);
  this.setZN(this.a);
  break;
}

// MOV (X),A
case 0xD6: {
  this.write(this.x, this.a);
  break;
}
// MOV X,#imm
case 0xCD:
  this.x = this.ram[this.pc++];
  this.setZN(this.x);
  break;

// MOV Y,#imm
case 0x8D:
  this.y = this.ram[this.pc++];
  this.setZN(this.y);
  break;

// INC X
case 0x3D:
  this.x = (this.x + 1) & 255;
  this.setZN(this.x);
  break;
// MOV dp,dp
case 0xFA: {
  const src = this.ram[this.pc++];
  const dst = this.ram[this.pc++];
  this.write(dst, this.read(src));
  break;
}
// MOV dp,#imm
case 0x8F: {
  const imm = this.ram[this.pc++];
  const dp = this.ram[this.pc++];
  this.write(dp, imm);
  break;
}

// MOV A,dp
case 0xE4: {
  const dp = this.ram[this.pc++];
  this.a = this.read(dp);
  this.setZN(this.a);
  break;
}

// MOV dp,A
case 0xC4: {
  const dp = this.ram[this.pc++];
  this.write(dp, this.a);
  break;
}
// MOV !addr,A
case 0xC5: {
  const lo = this.ram[this.pc++];
  const hi = this.ram[this.pc++];
  const addr = lo | (hi<<8);
  this.write(addr, this.a);
  break;
}

// MOV A,!addr
case 0xE5: {
  const lo = this.ram[this.pc++];
  const hi = this.ram[this.pc++];
  const addr = lo | (hi<<8);
  this.a = this.read(addr);
  this.setZN(this.a);
  break;
}
// MOV X,#imm
case 0xCD:
  this.x = this.ram[this.pc++];
  this.setZN(this.x);
  break;

// MOV Y,#imm
case 0x8D:
  this.y = this.ram[this.pc++];
  this.setZN(this.y);
  break;
  // DEC X
case 0x1D:
  this.x = (this.x - 1) & 255;
  this.setZN(this.x);
  break;

// BNE（既にある）
// MOV A,(X)
case 0xE6:
  this.a = this.read(this.x);
  this.setZN(this.a);
  break;

// MOV (X),A
case 0xC6:
  this.write(this.x, this.a);
  break;
// DEC X
case 0x1D:
  this.x = (this.x - 1) & 255;
  this.setZN(this.x);
  break;
      // BRA
      case 0x2F: {
        const rel = this.ram[this.pc++];
        this.pc += (rel < 128 ? rel : rel-256);
        break;
      }

      // NOP
      case 0x00:
        break;

default:
  
  break;
    }
  }

  read(addr) {
    if (addr === 0xFD) return this.timer[0];
    if (addr === 0xFE) return this.timer[1];
    if (addr === 0xFF) return this.timer[2];
    return this.ram[addr];
  }

  write(addr, v) {

  // DSP register select
  if (addr === 0xF2) {
    this.dspAddr = v & 0x7F;
    return;
  }

  // DSP data write
  if (addr === 0xF3) {
  console.log("a")
  this.dsp.writeReg(this.dspAddr, v);
}
 

  // Timer control
  if (addr === 0xF1) {
    this.timerEnable = v;
    return;
  }

  // Timer targets
  if (addr >= 0xFA && addr <= 0xFC) {
    this.timerTarget[addr - 0xFA] = v || 256;
    return;
  }

  this.ram[addr] = v;
}

  tickTimers() {
    for (let i=0;i<3;i++) {
      this.timerCounter[i]++;
      if (this.timerCounter[i] >= this.timerTarget[i]) {
        this.timerCounter[i] = 0;
        this.timer[i] = (this.timer[i]+1)&255;
      }
    }
  }
}
// --- DSP Emulator ---
class SNESDSP {
  constructor(spcFile) {
    this.ram = spcFile.ram;
    this.regs = new Uint8Array(128);
    this.regs.set(spcFile.dspRegs);

    this.voices = [];
    for (let i = 0; i < 8; i++) {
      this.voices.push({
        id: i,
        brrBuf: null,
        brrPos: 0.0,
        startAddr: 0,
        loopAddr: 0,
        env: 0,
        envMode: 0, // 0=attack,1=decay,2=sustain,3=release
        envLevel: 0,
        active: false,
        konBit: false,
        pitch: 0,
        volume: [0, 0],
        sampleHistory: [0, 0],
        // decoded cache
        decoded: null,
      });
    }

    this.mainVol = [this.regs[0x0C], this.regs[0x1C]];
    this.echoVol = [this.regs[0x2C], this.regs[0x3C]];
    this.kon = this.regs[0x4C];
    this.kof = this.regs[0x5C];
    this.flg = this.regs[0x6C];
    this.endx = 0;
    this.dir  = this.regs[0x5D]; // sample directory page

    // Pre-decode all voices
    this._initVoices();
  }

  _initVoices() {
    const dir = this.dir;
    for (let v = 0; v < 8; v++) {
      const voice = this.voices[v];
      const base = v * 16;

      voice.volume = [
        signedByte(this.regs[base + 0]),
        signedByte(this.regs[base + 1])
      ];
      voice.pitch = ((this.regs[base + 2]) | (this.regs[base + 3] << 8)) & 0x3FFF;

      const srcn = this.regs[base + 4];
      const dirBase = dir * 0x100;
      const entryAddr = dirBase + srcn * 4;

      if (entryAddr + 3 < this.ram.length) {
        voice.startAddr = this.ram[entryAddr] | (this.ram[entryAddr + 1] << 8);
        voice.loopAddr  = this.ram[entryAddr + 2] | (this.ram[entryAddr + 3] << 8);
      }

      // ADSR
      const adsr1 = this.regs[base + 5];
      const adsr2 = this.regs[base + 6];
      const gain  = this.regs[base + 7];
      voice.adsr1 = adsr1;
      voice.adsr2 = adsr2;
      voice.gain  = gain;

      // Pre-decode BRR
      voice.decoded = decodeBRR(this.ram, voice.startAddr, voice.loopAddr, 32000 * PLAY_DURATION);
      voice.brrPos  = 0;

      // KON bit enables voice
      voice.active = !!(this.kon & (1 << v));
      voice.envLevel = voice.active ? 1 : 0;
    }
  }

  // render one stereo sample, returns [L, R]
  render() {
    let L = 0, R = 0;

    for (let v = 0; v < 8; v++) {
      const voice = this.voices[v];
      if (!voice.active || !voice.decoded) continue;

      const decoded = voice.decoded;
      const pos = Math.floor(voice.brrPos);
      if (pos >= decoded.length) {
        voice.active = false;
        continue;
      }

      // Interpolate (linear)
      const frac = voice.brrPos - pos;
      const s0 = decoded[pos] || 0;
      const s1 = decoded[Math.min(pos + 1, decoded.length - 1)] || 0;
      let sample = s0 + (s1 - s0) * frac;

      // Envelope
      sample *= voice.envLevel;

      // Pitch advance: pitch is 4096 = 1x speed at 32kHz
      const pitchStep = voice.pitch / 4096.0;
      voice.brrPos += pitchStep;

      // Volume
      const vol = Math.max(1, Math.abs(voice.volume[0]) + Math.abs(voice.volume[1]));
      L += sample * voice.volume[0] / 128.0;
      R += sample * voice.volume[1] / 128.0;

      // Simple envelope decay
      voice.envLevel = Math.min(1, voice.envLevel + 0.001);
    }

    // Master volume
    const mvL = signedByte(this.regs[0x0C]) / 128.0;
    const mvR = signedByte(this.regs[0x1C]) / 128.0;

    return [L * mvL, R * mvR];
  }
writeReg(addr, val) {
  this.regs[addr] = val;

  if (addr === 0x4C) { // KON
    this.kon = val;
    for (let v=0;v<8;v++) {
      if (val & (1<<v)) {
        const voice = this.voices[v];
        voice.active = true;
        voice.brrPos = 0;
        voice.envLevel = 0;
        voice.envMode = 0;
      }
    }
  }

  if (addr === 0x5C) { // KOF
    for (let v=0;v<8;v++) {
      if (val & (1<<v)) {
        this.voices[v].envMode = 3;
      }
    }
  }
}
  getVoiceLevels() {
    return this.voices.map(v => {
      if (!v.active || !v.decoded) return 0;
      const pos = Math.floor(v.brrPos);
      if (pos >= v.decoded.length) return 0;
      return Math.abs(v.decoded[pos] * v.envLevel);
    });
  }
}

function signedByte(b) {
  return (b >= 128) ? b - 256 : b;
}

// ============================================================
//  Audio context & playback
// ============================================================

let audioCtx = null;
let gainNode = null;
let sourceNode = null;
let spcFile = null;
let isPlaying = false;
let playStartTime = 0;
let playDuration = PLAY_DURATION;
let audioBuffer = null;
let volLevel = 0.7;
let voiceLevels = new Float32Array(8);
let vizData = null;
let animFrame = null;

// Voice meter elements
const voiceMetersEl = document.getElementById('voiceMeters');
for (let i = 0; i < 8; i++) {
  const bar = document.createElement('div');
  bar.className = 'voice-bar';
  bar.innerHTML = `<div class="voice-fill"><div class="voice-level" id="vl${i}"></div></div><div class="voice-num">CH${i+1}</div>`;
  voiceMetersEl.appendChild(bar);
}

// DSP register display
const dspKeys = [
  ['VOL L', 0x0C], ['VOL R', 0x1C], ['KON', 0x4C], ['KOF', 0x5C],
  ['FLG', 0x6C], ['DIR', 0x5D], ['EVOL L', 0x2C], ['EVOL R', 0x3C]
];
const dspGridEl = document.getElementById('dspGrid');
for (const [name, addr] of dspKeys) {
  const el = document.createElement('div');
  el.className = 'dsp-reg';
  el.innerHTML = `<div class="dsp-reg-name">${name}</div><div class="dsp-reg-val" id="dr_${name.replace(' ','_')}">--</div>`;
  dspGridEl.appendChild(el);
}

document.getElementById('fileInput').onchange = async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  log('LOADING: ' + file.name);
  setStatus('LOADING...', '');

  const buf = await file.arrayBuffer();
  const data = new Uint8Array(buf);
  spcFile = new SPCFile(data);

  if (!spcFile.valid) {
    log('ERROR: Not a valid SPC file');
    setStatus('INVALID FILE', 'err');
    return;
  }

  document.getElementById('trackName').textContent = spcFile.songTitle || file.name;
  document.getElementById('gameName').textContent  = spcFile.gameName  || '---';
  document.getElementById('dumperName').textContent = spcFile.dumperName || '---';
  document.getElementById('dumpDate').textContent  = spcFile.dumpDate  || '---';

  playDuration = spcFile.secondsLen || 180;
  document.getElementById('timeTotal').textContent = fmtTime(playDuration);

  // Update DSP registers display
  for (const [name, addr] of dspKeys) {
    const el = document.getElementById('dr_' + name.replace(' ', '_'));
    if (el) el.textContent = hex2(spcFile.dspRegs[addr]);
  }

  log('DECODING BRR SAMPLES...');
  setStatus('DECODING...', '');

  // Async decode to avoid blocking UI
  await new Promise(r => setTimeout(r, 0));

  try {
    



    const dsp = new SNESDSP(spcFile);
const spc = new SPC700(spcFile, dsp);
//updateTrace(spc);
    // Render audio
    const totalSamples = SAMPLE_RATE * playDuration;
    //audioBuffer = renderAudio(dsp, totalSamples,spc);
audioBuffer = renderAudio(dsp, totalSamples, spcFile);
    // Build viz data (downsample for waveform)
    buildVizData(audioBuffer);

    setStatus('READY', 'ok');
    log('DECODED OK // ' + playDuration + 's // ' + (audioBuffer.length / SAMPLE_RATE).toFixed(1) + 's AUDIO');
    document.getElementById('btnPlay').disabled = false;
  } catch(err) {
    log('ERROR: ' + err.message);
    setStatus('ERROR', 'err');
    console.error(err);
  }
};
function renderAudio(dsp, totalSamples, spcFile) {

  const spc = new SPC700(spcFile, dsp); // ← CPUを使う

  const L = new Float32Array(totalSamples);
  const R = new Float32Array(totalSamples);

  for (let i = 0; i < totalSamples; i++) {

    // ⭐ CPUを回す（ここが最重要）
    for (let c = 0; c < 64; c++) {
      spc.step();
    }

    spc.tickTimers();

    const [l, r] = dsp.render();

    L[i] = l;
    R[i] = r;
  }

  return {L, R, length: totalSamples};
}
function buildVizData(audioBuf) {
  const downsample = 256;
  const n = Math.floor(audioBuf.length / downsample);
  vizData = new Float32Array(n);
  for (let i = 0; i < n; i++) {
    let sum = 0;
    const base = i * downsample;
    for (let j = 0; j < downsample; j++) {
      const v = (audioBuf.L[base + j] + audioBuf.R[base + j]) * 0.5;
      sum += Math.abs(v);
    }
    vizData[i] = sum / downsample;
  }
}

function togglePlay() {
  if (isPlaying) {
    pausePlayback();
  } else {
    startPlayback();
  }
}
function updateTrace(spc){
  const el = document.getElementById("cpuTrace");
  el.textContent = spc.traceBuffer;
  el.scrollTop = el.scrollHeight;
}

function startPlayback() {
  if (!audioBuffer) return;

  stopPlayback();

  audioCtx = new AudioContext({ sampleRate: SAMPLE_RATE });
  gainNode = audioCtx.createGain();
  gainNode.gain.value = volLevel;
  gainNode.connect(audioCtx.destination);

  const abuf = audioCtx.createBuffer(2, audioBuffer.length, SAMPLE_RATE);
  abuf.copyToChannel(audioBuffer.L, 0);
  abuf.copyToChannel(audioBuffer.R, 1);

  sourceNode = audioCtx.createBufferSource();
  sourceNode.buffer = abuf;
  sourceNode.connect(gainNode);
  sourceNode.onended = () => {
    if (isPlaying) {
      isPlaying = false;
      document.getElementById('btnPlay').textContent = '▶ PLAY';
      document.getElementById('btnPlay').classList.remove('active');
    }
  };
  sourceNode.start(0);
  playStartTime = audioCtx.currentTime;
  isPlaying = true;
  document.getElementById('btnPlay').textContent = '⏸ PAUSE';
  document.getElementById('btnPlay').classList.add('active');
  startUI();
}

function pausePlayback() {
  if (audioCtx) audioCtx.suspend();
  isPlaying = false;
  document.getElementById('btnPlay').textContent = '▶ PLAY';
  document.getElementById('btnPlay').classList.remove('active');
}

function stopPlayback() {
  if (sourceNode) { try { sourceNode.stop(); } catch(e) {} }
  if (audioCtx) { try { audioCtx.close(); } catch(e) {} }
  sourceNode = null; audioCtx = null; gainNode = null;
  isPlaying = false;
  document.getElementById('btnPlay').textContent = '▶ PLAY';
  document.getElementById('btnPlay').classList.remove('active');
  document.getElementById('progressFill').style.width = '0%';
  document.getElementById('timeElapsed').textContent = '0:00';
  cancelAnimationFrame(animFrame);
}

function setVolume(v) {
  volLevel = v / 100;
  if (gainNode) gainNode.gain.value = volLevel;
}

function startUI() {
  const canvas = document.getElementById('waveCanvas');
  const ctx = canvas.getContext('2d');
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;

  function update() {
    if (!audioCtx) return;
    const elapsed = audioCtx.currentTime - playStartTime;
    const pct = Math.min(1, elapsed / playDuration);

    document.getElementById('progressFill').style.width = (pct * 100) + '%';
    document.getElementById('timeElapsed').textContent = fmtTime(Math.floor(elapsed));

    // Update voice meters
    if (window._voiceCaptures) {
      const capIdx = Math.floor(elapsed * SAMPLE_RATE / window._voiceCapInterval);
      const caps = window._voiceCaptures[Math.min(capIdx, window._voiceCaptures.length - 1)];
      if (caps) {
        for (let v = 0; v < 8; v++) {
          const el = document.getElementById('vl' + v);
          if (el) el.style.height = Math.min(100, caps[v] * 100 * 3) + '%';
        }
      }
    }

    // Draw waveform
    if (vizData) drawWaveform(ctx, canvas, pct);

    animFrame = requestAnimationFrame(update);
  }
  update();
}

function drawWaveform(ctx, canvas, progress) {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  const N = vizData.length;
  const played = Math.floor(progress * N);

  // Background grid
  ctx.strokeStyle = '#1a1a2e';
  ctx.lineWidth = 1;
  for (let x = 0; x < W; x += 40) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }

  // Waveform
  const barW = Math.max(1, W / N);

  for (let i = 0; i < N; i++) {
    const x = (i / N) * W;
    const amp = Math.min(1, vizData[i] * 4);
    const barH = amp * H;

    if (i <= played) {
      ctx.fillStyle = `rgba(0,255,157,${0.4 + amp * 0.5})`;
    } else {
      ctx.fillStyle = `rgba(26,30,58,0.8)`;
    }

    ctx.fillRect(x, (H - barH) / 2, Math.max(1, barW - 0.5), barH);
  }

  // Playhead
  const px = progress * W;
  ctx.strokeStyle = '#3c9eff';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(px, 0);
  ctx.lineTo(px, H);
  ctx.stroke();
}

function fmtTime(s) {
  const m = Math.floor(s / 60);
  return m + ':' + String(Math.floor(s) % 60).padStart(2, '0');
}

function hex2(v) { return v != null ? v.toString(16).toUpperCase().padStart(2, '0') : '--'; }

function log(msg) {
  const el = document.getElementById('log');
  el.textContent = '> ' + msg;
  el.className = 'log';
}

function setStatus(msg, cls) {
  const el = document.getElementById('status');
  el.textContent = msg;
  el.className = 'status ' + (cls || '');
}
</script>
</body>
</html>